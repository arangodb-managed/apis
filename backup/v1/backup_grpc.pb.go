//
// DISCLAIMER
//
// Copyright 2020 ArangoDB GmbH, Cologne, Germany
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright holder is ArangoDB GmbH, Cologne, Germany
//
// Author Robert Stam
//

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: backup.proto

package v1

import (
	context "context"
	v1 "github.com/arangodb-managed/apis/common/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BackupService_GetAPIVersion_FullMethodName                             = "/arangodb.cloud.backup.v1.BackupService/GetAPIVersion"
	BackupService_IsBackupFeatureAvailable_FullMethodName                  = "/arangodb.cloud.backup.v1.BackupService/IsBackupFeatureAvailable"
	BackupService_IsBackupUploadFeatureAvailable_FullMethodName            = "/arangodb.cloud.backup.v1.BackupService/IsBackupUploadFeatureAvailable"
	BackupService_IsMultiRegionBackupUploadFeatureAvailable_FullMethodName = "/arangodb.cloud.backup.v1.BackupService/IsMultiRegionBackupUploadFeatureAvailable"
	BackupService_ListBackupPolicies_FullMethodName                        = "/arangodb.cloud.backup.v1.BackupService/ListBackupPolicies"
	BackupService_GetBackupPolicy_FullMethodName                           = "/arangodb.cloud.backup.v1.BackupService/GetBackupPolicy"
	BackupService_CreateBackupPolicy_FullMethodName                        = "/arangodb.cloud.backup.v1.BackupService/CreateBackupPolicy"
	BackupService_UpdateBackupPolicy_FullMethodName                        = "/arangodb.cloud.backup.v1.BackupService/UpdateBackupPolicy"
	BackupService_DeleteBackupPolicy_FullMethodName                        = "/arangodb.cloud.backup.v1.BackupService/DeleteBackupPolicy"
	BackupService_ListBackups_FullMethodName                               = "/arangodb.cloud.backup.v1.BackupService/ListBackups"
	BackupService_GetBackup_FullMethodName                                 = "/arangodb.cloud.backup.v1.BackupService/GetBackup"
	BackupService_CreateBackup_FullMethodName                              = "/arangodb.cloud.backup.v1.BackupService/CreateBackup"
	BackupService_UpdateBackup_FullMethodName                              = "/arangodb.cloud.backup.v1.BackupService/UpdateBackup"
	BackupService_DownloadBackup_FullMethodName                            = "/arangodb.cloud.backup.v1.BackupService/DownloadBackup"
	BackupService_RestoreBackup_FullMethodName                             = "/arangodb.cloud.backup.v1.BackupService/RestoreBackup"
	BackupService_DeleteBackup_FullMethodName                              = "/arangodb.cloud.backup.v1.BackupService/DeleteBackup"
	BackupService_CopyBackup_FullMethodName                                = "/arangodb.cloud.backup.v1.BackupService/CopyBackup"
)

// BackupServiceClient is the client API for BackupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// BackupService is the API used to configure backup objects.
type BackupServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error)
	// Checks if the backup feature is enabled and available for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsBackupFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error)
	// Checks if the backup upload feature is enabled for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsBackupUploadFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error)
	// Checks if the multi region backup upload feature is enabled for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsMultiRegionBackupUploadFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error)
	// Fetch all backup policies for a specific deployment.
	// Required permissions:
	// - backup.backuppolicy.list on the deployment that owns the backup policies and is identified by the given ID.
	ListBackupPolicies(ctx context.Context, in *ListBackupPoliciesRequest, opts ...grpc.CallOption) (*BackupPolicyList, error)
	// Fetch a backup policy identified by the given ID.
	// Required permissions:
	// - backup.backuppolicy.get on the backup policy identified by the given ID.
	GetBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*BackupPolicy, error)
	// Create a new backup policy
	// Required permissions:
	// -  backup.backuppolicy.create on the deployment that owns the backup policy and is identified by the given ID.
	CreateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error)
	// Update a backup policy
	// Required permissions:
	// -  backup.backuppolicy.update on the backup policy identified by the given ID.
	UpdateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error)
	// Delete a backup policy identified by the given ID.
	// Note that the backup policy are initially only marked for deletion, no backups will be deleted with this operation.
	// Once all their dependent backups are removed, the backup policy is removed.
	// Required permissions:
	// -  backup.backuppolicy.delete on the backup policy identified by the given ID.
	DeleteBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Fetch all backups for a specific deployment.
	// Required permissions:
	// - backup.backup.list on the deployment that owns the backup and is identified by the given ID.
	ListBackups(ctx context.Context, in *ListBackupsRequest, opts ...grpc.CallOption) (*BackupList, error)
	// Fetch a backup identified by the given ID.
	// Required permissions:
	// - backup.backup.get on the backup identified by the given ID.
	GetBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Backup, error)
	// Create a new manual backup
	// Setting the backup_policy_id field in the backup is not allowed
	// Required permissions:
	// -  backup.backup.create on the deployment that owns the backup and is identified by the given ID.
	CreateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error)
	// Update a backup
	// Required permissions:
	// -  backup.backup.update on the backup identified by the given ID.
	UpdateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error)
	// Download a backup identified by the given ID from remote storage to the volumes of the servers of the deployment.
	// This operation can only be executed on backups which have the same number of DB Servers in the backup and the current running cluster.
	// If this backup was already downloaded, another download will be done.
	// If the backup is still available on the cluster there is no need to explicitly download the backup before restoring.
	// This function will return immediately.
	// To track status, please invoke GetBackup and check the .status field inside the returned backup object
	// Required permissions:
	// -  backup.backup.download on the backup identified by the given ID.
	DownloadBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Restore (or recover) a backup identified by the given ID
	// This operation can only be executed on backups where status.available is set and
	// the mayor and minor version of the backup and the current running cluster are the same.
	// This function will return immediately.
	// To track status, please invoke GetDeployment on the data API and check the
	// .status.restoring_backup and .status.restore_backup_status fields inside the returned deployment object
	// Required permissions (both are needed):
	// -  backup.backup.restore on the backup identified by the given ID.
	// -  data.deployment.restore-backup on the deployment that owns this backup
	RestoreBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Delete a backup identified by the given ID, after which removal of any remote storage of the backup is started.
	// Note that the backup are initially only marked for deletion.
	// Once all remote storage for the backup has been removed, the backup itself is removed.
	// Required permissions:
	// -  backup.backup.delete on the backup identified by the given ID.
	DeleteBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Copy a backup manually from source backup to a given region identifier.
	// It is not allowed to copy backup that does not have upload flag set to true
	// Required permissions:
	// - backup.backup.copy on the backup identified by the given ID.
	CopyBackup(ctx context.Context, in *CopyBackupRequest, opts ...grpc.CallOption) (*Backup, error)
}

type backupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBackupServiceClient(cc grpc.ClientConnInterface) BackupServiceClient {
	return &backupServiceClient{cc}
}

func (c *backupServiceClient) GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.Version)
	err := c.cc.Invoke(ctx, BackupService_GetAPIVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) IsBackupFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.YesOrNo)
	err := c.cc.Invoke(ctx, BackupService_IsBackupFeatureAvailable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) IsBackupUploadFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.YesOrNo)
	err := c.cc.Invoke(ctx, BackupService_IsBackupUploadFeatureAvailable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) IsMultiRegionBackupUploadFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.YesOrNo)
	err := c.cc.Invoke(ctx, BackupService_IsMultiRegionBackupUploadFeatureAvailable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) ListBackupPolicies(ctx context.Context, in *ListBackupPoliciesRequest, opts ...grpc.CallOption) (*BackupPolicyList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BackupPolicyList)
	err := c.cc.Invoke(ctx, BackupService_ListBackupPolicies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) GetBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*BackupPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BackupPolicy)
	err := c.cc.Invoke(ctx, BackupService_GetBackupPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) CreateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BackupPolicy)
	err := c.cc.Invoke(ctx, BackupService_CreateBackupPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) UpdateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BackupPolicy)
	err := c.cc.Invoke(ctx, BackupService_UpdateBackupPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) DeleteBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, BackupService_DeleteBackupPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) ListBackups(ctx context.Context, in *ListBackupsRequest, opts ...grpc.CallOption) (*BackupList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BackupList)
	err := c.cc.Invoke(ctx, BackupService_ListBackups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) GetBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Backup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Backup)
	err := c.cc.Invoke(ctx, BackupService_GetBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) CreateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Backup)
	err := c.cc.Invoke(ctx, BackupService_CreateBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) UpdateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Backup)
	err := c.cc.Invoke(ctx, BackupService_UpdateBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) DownloadBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, BackupService_DownloadBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) RestoreBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, BackupService_RestoreBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) DeleteBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, BackupService_DeleteBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) CopyBackup(ctx context.Context, in *CopyBackupRequest, opts ...grpc.CallOption) (*Backup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Backup)
	err := c.cc.Invoke(ctx, BackupService_CopyBackup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackupServiceServer is the server API for BackupService service.
// All implementations must embed UnimplementedBackupServiceServer
// for forward compatibility.
//
// BackupService is the API used to configure backup objects.
type BackupServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error)
	// Checks if the backup feature is enabled and available for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsBackupFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error)
	// Checks if the backup upload feature is enabled for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsBackupUploadFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error)
	// Checks if the multi region backup upload feature is enabled for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsMultiRegionBackupUploadFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error)
	// Fetch all backup policies for a specific deployment.
	// Required permissions:
	// - backup.backuppolicy.list on the deployment that owns the backup policies and is identified by the given ID.
	ListBackupPolicies(context.Context, *ListBackupPoliciesRequest) (*BackupPolicyList, error)
	// Fetch a backup policy identified by the given ID.
	// Required permissions:
	// - backup.backuppolicy.get on the backup policy identified by the given ID.
	GetBackupPolicy(context.Context, *v1.IDOptions) (*BackupPolicy, error)
	// Create a new backup policy
	// Required permissions:
	// -  backup.backuppolicy.create on the deployment that owns the backup policy and is identified by the given ID.
	CreateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error)
	// Update a backup policy
	// Required permissions:
	// -  backup.backuppolicy.update on the backup policy identified by the given ID.
	UpdateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error)
	// Delete a backup policy identified by the given ID.
	// Note that the backup policy are initially only marked for deletion, no backups will be deleted with this operation.
	// Once all their dependent backups are removed, the backup policy is removed.
	// Required permissions:
	// -  backup.backuppolicy.delete on the backup policy identified by the given ID.
	DeleteBackupPolicy(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Fetch all backups for a specific deployment.
	// Required permissions:
	// - backup.backup.list on the deployment that owns the backup and is identified by the given ID.
	ListBackups(context.Context, *ListBackupsRequest) (*BackupList, error)
	// Fetch a backup identified by the given ID.
	// Required permissions:
	// - backup.backup.get on the backup identified by the given ID.
	GetBackup(context.Context, *v1.IDOptions) (*Backup, error)
	// Create a new manual backup
	// Setting the backup_policy_id field in the backup is not allowed
	// Required permissions:
	// -  backup.backup.create on the deployment that owns the backup and is identified by the given ID.
	CreateBackup(context.Context, *Backup) (*Backup, error)
	// Update a backup
	// Required permissions:
	// -  backup.backup.update on the backup identified by the given ID.
	UpdateBackup(context.Context, *Backup) (*Backup, error)
	// Download a backup identified by the given ID from remote storage to the volumes of the servers of the deployment.
	// This operation can only be executed on backups which have the same number of DB Servers in the backup and the current running cluster.
	// If this backup was already downloaded, another download will be done.
	// If the backup is still available on the cluster there is no need to explicitly download the backup before restoring.
	// This function will return immediately.
	// To track status, please invoke GetBackup and check the .status field inside the returned backup object
	// Required permissions:
	// -  backup.backup.download on the backup identified by the given ID.
	DownloadBackup(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Restore (or recover) a backup identified by the given ID
	// This operation can only be executed on backups where status.available is set and
	// the mayor and minor version of the backup and the current running cluster are the same.
	// This function will return immediately.
	// To track status, please invoke GetDeployment on the data API and check the
	// .status.restoring_backup and .status.restore_backup_status fields inside the returned deployment object
	// Required permissions (both are needed):
	// -  backup.backup.restore on the backup identified by the given ID.
	// -  data.deployment.restore-backup on the deployment that owns this backup
	RestoreBackup(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Delete a backup identified by the given ID, after which removal of any remote storage of the backup is started.
	// Note that the backup are initially only marked for deletion.
	// Once all remote storage for the backup has been removed, the backup itself is removed.
	// Required permissions:
	// -  backup.backup.delete on the backup identified by the given ID.
	DeleteBackup(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Copy a backup manually from source backup to a given region identifier.
	// It is not allowed to copy backup that does not have upload flag set to true
	// Required permissions:
	// - backup.backup.copy on the backup identified by the given ID.
	CopyBackup(context.Context, *CopyBackupRequest) (*Backup, error)
	mustEmbedUnimplementedBackupServiceServer()
}

// UnimplementedBackupServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBackupServiceServer struct{}

func (UnimplementedBackupServiceServer) GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (UnimplementedBackupServiceServer) IsBackupFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsBackupFeatureAvailable not implemented")
}
func (UnimplementedBackupServiceServer) IsBackupUploadFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsBackupUploadFeatureAvailable not implemented")
}
func (UnimplementedBackupServiceServer) IsMultiRegionBackupUploadFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsMultiRegionBackupUploadFeatureAvailable not implemented")
}
func (UnimplementedBackupServiceServer) ListBackupPolicies(context.Context, *ListBackupPoliciesRequest) (*BackupPolicyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBackupPolicies not implemented")
}
func (UnimplementedBackupServiceServer) GetBackupPolicy(context.Context, *v1.IDOptions) (*BackupPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBackupPolicy not implemented")
}
func (UnimplementedBackupServiceServer) CreateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBackupPolicy not implemented")
}
func (UnimplementedBackupServiceServer) UpdateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBackupPolicy not implemented")
}
func (UnimplementedBackupServiceServer) DeleteBackupPolicy(context.Context, *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBackupPolicy not implemented")
}
func (UnimplementedBackupServiceServer) ListBackups(context.Context, *ListBackupsRequest) (*BackupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBackups not implemented")
}
func (UnimplementedBackupServiceServer) GetBackup(context.Context, *v1.IDOptions) (*Backup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBackup not implemented")
}
func (UnimplementedBackupServiceServer) CreateBackup(context.Context, *Backup) (*Backup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBackup not implemented")
}
func (UnimplementedBackupServiceServer) UpdateBackup(context.Context, *Backup) (*Backup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBackup not implemented")
}
func (UnimplementedBackupServiceServer) DownloadBackup(context.Context, *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadBackup not implemented")
}
func (UnimplementedBackupServiceServer) RestoreBackup(context.Context, *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreBackup not implemented")
}
func (UnimplementedBackupServiceServer) DeleteBackup(context.Context, *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBackup not implemented")
}
func (UnimplementedBackupServiceServer) CopyBackup(context.Context, *CopyBackupRequest) (*Backup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyBackup not implemented")
}
func (UnimplementedBackupServiceServer) mustEmbedUnimplementedBackupServiceServer() {}
func (UnimplementedBackupServiceServer) testEmbeddedByValue()                       {}

// UnsafeBackupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackupServiceServer will
// result in compilation errors.
type UnsafeBackupServiceServer interface {
	mustEmbedUnimplementedBackupServiceServer()
}

func RegisterBackupServiceServer(s grpc.ServiceRegistrar, srv BackupServiceServer) {
	// If the following call pancis, it indicates UnimplementedBackupServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BackupService_ServiceDesc, srv)
}

func _BackupService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_GetAPIVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).GetAPIVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_IsBackupFeatureAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).IsBackupFeatureAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_IsBackupFeatureAvailable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).IsBackupFeatureAvailable(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_IsBackupUploadFeatureAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).IsBackupUploadFeatureAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_IsBackupUploadFeatureAvailable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).IsBackupUploadFeatureAvailable(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_IsMultiRegionBackupUploadFeatureAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).IsMultiRegionBackupUploadFeatureAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_IsMultiRegionBackupUploadFeatureAvailable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).IsMultiRegionBackupUploadFeatureAvailable(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_ListBackupPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackupPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).ListBackupPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_ListBackupPolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).ListBackupPolicies(ctx, req.(*ListBackupPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_GetBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).GetBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_GetBackupPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).GetBackupPolicy(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_CreateBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).CreateBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_CreateBackupPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).CreateBackupPolicy(ctx, req.(*BackupPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_UpdateBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).UpdateBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_UpdateBackupPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).UpdateBackupPolicy(ctx, req.(*BackupPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_DeleteBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).DeleteBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_DeleteBackupPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).DeleteBackupPolicy(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_ListBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).ListBackups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_ListBackups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).ListBackups(ctx, req.(*ListBackupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_GetBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).GetBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_GetBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).GetBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_CreateBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Backup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).CreateBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_CreateBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).CreateBackup(ctx, req.(*Backup))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_UpdateBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Backup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).UpdateBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_UpdateBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).UpdateBackup(ctx, req.(*Backup))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_DownloadBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).DownloadBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_DownloadBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).DownloadBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_RestoreBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).RestoreBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_RestoreBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).RestoreBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_DeleteBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).DeleteBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_DeleteBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).DeleteBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_CopyBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).CopyBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackupService_CopyBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).CopyBackup(ctx, req.(*CopyBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BackupService_ServiceDesc is the grpc.ServiceDesc for BackupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BackupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.backup.v1.BackupService",
	HandlerType: (*BackupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _BackupService_GetAPIVersion_Handler,
		},
		{
			MethodName: "IsBackupFeatureAvailable",
			Handler:    _BackupService_IsBackupFeatureAvailable_Handler,
		},
		{
			MethodName: "IsBackupUploadFeatureAvailable",
			Handler:    _BackupService_IsBackupUploadFeatureAvailable_Handler,
		},
		{
			MethodName: "IsMultiRegionBackupUploadFeatureAvailable",
			Handler:    _BackupService_IsMultiRegionBackupUploadFeatureAvailable_Handler,
		},
		{
			MethodName: "ListBackupPolicies",
			Handler:    _BackupService_ListBackupPolicies_Handler,
		},
		{
			MethodName: "GetBackupPolicy",
			Handler:    _BackupService_GetBackupPolicy_Handler,
		},
		{
			MethodName: "CreateBackupPolicy",
			Handler:    _BackupService_CreateBackupPolicy_Handler,
		},
		{
			MethodName: "UpdateBackupPolicy",
			Handler:    _BackupService_UpdateBackupPolicy_Handler,
		},
		{
			MethodName: "DeleteBackupPolicy",
			Handler:    _BackupService_DeleteBackupPolicy_Handler,
		},
		{
			MethodName: "ListBackups",
			Handler:    _BackupService_ListBackups_Handler,
		},
		{
			MethodName: "GetBackup",
			Handler:    _BackupService_GetBackup_Handler,
		},
		{
			MethodName: "CreateBackup",
			Handler:    _BackupService_CreateBackup_Handler,
		},
		{
			MethodName: "UpdateBackup",
			Handler:    _BackupService_UpdateBackup_Handler,
		},
		{
			MethodName: "DownloadBackup",
			Handler:    _BackupService_DownloadBackup_Handler,
		},
		{
			MethodName: "RestoreBackup",
			Handler:    _BackupService_RestoreBackup_Handler,
		},
		{
			MethodName: "DeleteBackup",
			Handler:    _BackupService_DeleteBackup_Handler,
		},
		{
			MethodName: "CopyBackup",
			Handler:    _BackupService_CopyBackup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "backup.proto",
}
