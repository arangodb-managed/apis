//
// DISCLAIMER
//
// Copyright 2020 ArangoDB GmbH, Cologne, Germany
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright holder is ArangoDB GmbH, Cologne, Germany
//
// Author Robert Stam
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.33.0
// 	protoc        v5.28.3
// source: backup.proto

package v1

import (
	context "context"
	v1 "github.com/arangodb-managed/apis/common/v1"
	v11 "github.com/arangodb-managed/apis/data/v1"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// BackupPolicy represents a single backup policy for a deployment.
type BackupPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// System identifier of the backup policy.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of this resource
	// This is a read-only value.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Name of the backup policy
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the backup policy
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Identifier of the deployment that owns this backup policy.
	// After creation, this value cannot be changed.
	DeploymentId string `protobuf:"bytes,5,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// The creation timestamp of the backup policy
	// This is a read-only value.
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// The deletion timestamp of the backup policy
	// This is a read-only value.
	DeletedAt *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Set when this backup policy is deleted.
	// This is a read-only value.
	IsDeleted bool `protobuf:"varint,8,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// Pause this backup policy.
	// If a backup policy is paused, the backup policy will not result in new backups.
	// The backup policy isn't deleted, unsetting this field will resume the creation of backups again.
	IsPaused bool `protobuf:"varint,9,opt,name=is_paused,json=isPaused,proto3" json:"is_paused,omitempty"`
	// The schedule for this backup policy
	Schedule *BackupPolicy_Schedule `protobuf:"bytes,10,opt,name=schedule,proto3" json:"schedule,omitempty"`
	// Upload the backup, created by the backup policy, to an external source.
	Upload bool `protobuf:"varint,11,opt,name=upload,proto3" json:"upload,omitempty"`
	// Backups created by this policy will be automatically deleted after the specified retention period
	// A value of 0 means that backup will never be deleted.
	RetentionPeriod *durationpb.Duration `protobuf:"bytes,12,opt,name=retention_period,json=retentionPeriod,proto3" json:"retention_period,omitempty"`
	// The owners of the organization can be notified by email
	// This field support the following values: "Never|FailureOnly|Always"
	EmailNotification string `protobuf:"bytes,13,opt,name=email_notification,json=emailNotification,proto3" json:"email_notification,omitempty"`
	// If set, this backup policy cannot be deleted.
	// To delete, first update the with locked set to false.
	Locked bool `protobuf:"varint,14,opt,name=locked,proto3" json:"locked,omitempty"`
	// Status of the backup policy
	Status *BackupPolicy_Status `protobuf:"bytes,100,opt,name=status,proto3" json:"status,omitempty"`
	// List of region identifiers where the backup should be uploaded
	// in addition to the region where the deployment is running.
	// If not set, it should be uploaded to the same region as where the deployment is running.
	// This field can be filled-out only for policies where 'upload' is set.
	AdditionalRegionIds []string `protobuf:"bytes,101,rep,name=additional_region_ids,json=additionalRegionIds,proto3" json:"additional_region_ids,omitempty"`
}

func (x *BackupPolicy) Reset() {
	*x = BackupPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BackupPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupPolicy) ProtoMessage() {}

func (x *BackupPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupPolicy.ProtoReflect.Descriptor instead.
func (*BackupPolicy) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{0}
}

func (x *BackupPolicy) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *BackupPolicy) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *BackupPolicy) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BackupPolicy) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *BackupPolicy) GetDeploymentId() string {
	if x != nil {
		return x.DeploymentId
	}
	return ""
}

func (x *BackupPolicy) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *BackupPolicy) GetDeletedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.DeletedAt
	}
	return nil
}

func (x *BackupPolicy) GetIsDeleted() bool {
	if x != nil {
		return x.IsDeleted
	}
	return false
}

func (x *BackupPolicy) GetIsPaused() bool {
	if x != nil {
		return x.IsPaused
	}
	return false
}

func (x *BackupPolicy) GetSchedule() *BackupPolicy_Schedule {
	if x != nil {
		return x.Schedule
	}
	return nil
}

func (x *BackupPolicy) GetUpload() bool {
	if x != nil {
		return x.Upload
	}
	return false
}

func (x *BackupPolicy) GetRetentionPeriod() *durationpb.Duration {
	if x != nil {
		return x.RetentionPeriod
	}
	return nil
}

func (x *BackupPolicy) GetEmailNotification() string {
	if x != nil {
		return x.EmailNotification
	}
	return ""
}

func (x *BackupPolicy) GetLocked() bool {
	if x != nil {
		return x.Locked
	}
	return false
}

func (x *BackupPolicy) GetStatus() *BackupPolicy_Status {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *BackupPolicy) GetAdditionalRegionIds() []string {
	if x != nil {
		return x.AdditionalRegionIds
	}
	return nil
}

// TimeOfDay describes a specific moment on a day
type TimeOfDay struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Hours part of the time of day (0-23)
	Hours int32 `protobuf:"varint,1,opt,name=hours,proto3" json:"hours,omitempty"`
	// Minutes part of the time of day (0-59)
	Minutes int32 `protobuf:"varint,2,opt,name=minutes,proto3" json:"minutes,omitempty"`
	// The time-zone this time of day applies to (empty means UTC)
	// Names MUST be exactly as defined in RFC-822.
	TimeZone string `protobuf:"bytes,3,opt,name=time_zone,json=timeZone,proto3" json:"time_zone,omitempty"`
}

func (x *TimeOfDay) Reset() {
	*x = TimeOfDay{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TimeOfDay) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimeOfDay) ProtoMessage() {}

func (x *TimeOfDay) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimeOfDay.ProtoReflect.Descriptor instead.
func (*TimeOfDay) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{1}
}

func (x *TimeOfDay) GetHours() int32 {
	if x != nil {
		return x.Hours
	}
	return 0
}

func (x *TimeOfDay) GetMinutes() int32 {
	if x != nil {
		return x.Minutes
	}
	return 0
}

func (x *TimeOfDay) GetTimeZone() string {
	if x != nil {
		return x.TimeZone
	}
	return ""
}

// List of backup policies.
type BackupPolicyList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Items []*BackupPolicy `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	// Budget for backup policies
	Budget *v1.Budget `protobuf:"bytes,2,opt,name=budget,proto3" json:"budget,omitempty"`
}

func (x *BackupPolicyList) Reset() {
	*x = BackupPolicyList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BackupPolicyList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupPolicyList) ProtoMessage() {}

func (x *BackupPolicyList) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupPolicyList.ProtoReflect.Descriptor instead.
func (*BackupPolicyList) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{2}
}

func (x *BackupPolicyList) GetItems() []*BackupPolicy {
	if x != nil {
		return x.Items
	}
	return nil
}

func (x *BackupPolicyList) GetBudget() *v1.Budget {
	if x != nil {
		return x.Budget
	}
	return nil
}

// Request arguments for ListBackupPolicies
type ListBackupPoliciesRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Identifier of the deployment to request the backup policies for.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// If set, the result includes all backup policies, including those who set to deleted,
	// however are not removed from the system currently.
	// If not set, only backup policies not indicated as deleted are returned.
	IncludeDeleted bool `protobuf:"varint,2,opt,name=include_deleted,json=includeDeleted,proto3" json:"include_deleted,omitempty"`
	// Optional common list options, the context_id is ignored
	Options *v1.ListOptions `protobuf:"bytes,10,opt,name=options,proto3" json:"options,omitempty"`
}

func (x *ListBackupPoliciesRequest) Reset() {
	*x = ListBackupPoliciesRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListBackupPoliciesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListBackupPoliciesRequest) ProtoMessage() {}

func (x *ListBackupPoliciesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListBackupPoliciesRequest.ProtoReflect.Descriptor instead.
func (*ListBackupPoliciesRequest) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{3}
}

func (x *ListBackupPoliciesRequest) GetDeploymentId() string {
	if x != nil {
		return x.DeploymentId
	}
	return ""
}

func (x *ListBackupPoliciesRequest) GetIncludeDeleted() bool {
	if x != nil {
		return x.IncludeDeleted
	}
	return false
}

func (x *ListBackupPoliciesRequest) GetOptions() *v1.ListOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

// Backup represents a single backup of a deployment.
type Backup struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// System identifier of the backup.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of this resource
	// This is a read-only value.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Name of the backup
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the backup
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Identifier of the deployment that owns this backup.
	// After creation, this value cannot be changed.
	DeploymentId string `protobuf:"bytes,5,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Identifier of the backup policy that triggered this backup
	// After creation, this value cannot be changed.
	// If this field is empty, this is a manual backup
	BackupPolicyId string `protobuf:"bytes,6,opt,name=backup_policy_id,json=backupPolicyId,proto3" json:"backup_policy_id,omitempty"`
	// The creation timestamp of the backup (database object)
	// This is a read-only value.
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// The deletion timestamp of the backup
	// This is a read-only value.
	DeletedAt *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Set when this backup is deleted.
	// This is a read-only value.
	IsDeleted bool `protobuf:"varint,9,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// The timestamp that this backup will be automatically removed
	// You cannot provide a value in the past,
	// If the field is not set, the backup will not be automatically removed.
	AutoDeletedAt *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=auto_deleted_at,json=autoDeletedAt,proto3" json:"auto_deleted_at,omitempty"`
	// Information about the deployment during backup
	DeploymentInfo *Backup_DeploymentInfo `protobuf:"bytes,11,opt,name=deployment_info,json=deploymentInfo,proto3" json:"deployment_info,omitempty"`
	// Upload the backup, created by the backup policy, to an external source.
	// Setting or unsetting this fields after the backup has been created will upload/delete the backup from the external source.
	// Setting this field when status.available = false will result in an error
	Upload bool `protobuf:"varint,12,opt,name=upload,proto3" json:"upload,omitempty"`
	// The timestamp of when the upload boolean has been updated.
	// This is a read-only value.
	UploadUpdatedAt *timestamppb.Timestamp `protobuf:"bytes,14,opt,name=upload_updated_at,json=uploadUpdatedAt,proto3" json:"upload_updated_at,omitempty"`
	// Information about a backup download.
	// If this field is set the backup will be downloaded the deployment.
	// This is a read-only field. To set this field please use the DownloadBackup method.
	Download *Backup_DownloadSpec `protobuf:"bytes,13,opt,name=download,proto3" json:"download,omitempty"`
	// Identifier of the user who created this backup.
	// This field is set only for manual backups.
	// This is a read-only value.
	CreatedById string `protobuf:"bytes,15,opt,name=created_by_id,json=createdById,proto3" json:"created_by_id,omitempty"`
	// Status of the actual backup
	Status *Backup_Status `protobuf:"bytes,100,opt,name=status,proto3" json:"status,omitempty"`
	// Identifier of the region in which backup is stored
	// If not set, backup is stored in the same region as of deployment
	// This is a read-only field
	RegionId string `protobuf:"bytes,101,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// Identifier of the backup from which this backup is cloned.
	// If not set, backup is not multi-region backup.
	// This is a read-only field
	SourceBackupId string `protobuf:"bytes,102,opt,name=source_backup_id,json=sourceBackupId,proto3" json:"source_backup_id,omitempty"`
}

func (x *Backup) Reset() {
	*x = Backup{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Backup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backup) ProtoMessage() {}

func (x *Backup) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backup.ProtoReflect.Descriptor instead.
func (*Backup) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{4}
}

func (x *Backup) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Backup) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *Backup) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Backup) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Backup) GetDeploymentId() string {
	if x != nil {
		return x.DeploymentId
	}
	return ""
}

func (x *Backup) GetBackupPolicyId() string {
	if x != nil {
		return x.BackupPolicyId
	}
	return ""
}

func (x *Backup) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Backup) GetDeletedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.DeletedAt
	}
	return nil
}

func (x *Backup) GetIsDeleted() bool {
	if x != nil {
		return x.IsDeleted
	}
	return false
}

func (x *Backup) GetAutoDeletedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.AutoDeletedAt
	}
	return nil
}

func (x *Backup) GetDeploymentInfo() *Backup_DeploymentInfo {
	if x != nil {
		return x.DeploymentInfo
	}
	return nil
}

func (x *Backup) GetUpload() bool {
	if x != nil {
		return x.Upload
	}
	return false
}

func (x *Backup) GetUploadUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UploadUpdatedAt
	}
	return nil
}

func (x *Backup) GetDownload() *Backup_DownloadSpec {
	if x != nil {
		return x.Download
	}
	return nil
}

func (x *Backup) GetCreatedById() string {
	if x != nil {
		return x.CreatedById
	}
	return ""
}

func (x *Backup) GetStatus() *Backup_Status {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *Backup) GetRegionId() string {
	if x != nil {
		return x.RegionId
	}
	return ""
}

func (x *Backup) GetSourceBackupId() string {
	if x != nil {
		return x.SourceBackupId
	}
	return ""
}

// List of backups.
type BackupList struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Items []*Backup `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	// Budget for backups
	Budget *v1.Budget `protobuf:"bytes,2,opt,name=budget,proto3" json:"budget,omitempty"`
}

func (x *BackupList) Reset() {
	*x = BackupList{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BackupList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupList) ProtoMessage() {}

func (x *BackupList) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupList.ProtoReflect.Descriptor instead.
func (*BackupList) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{5}
}

func (x *BackupList) GetItems() []*Backup {
	if x != nil {
		return x.Items
	}
	return nil
}

func (x *BackupList) GetBudget() *v1.Budget {
	if x != nil {
		return x.Budget
	}
	return nil
}

// Request arguments for ListBackups
type ListBackupsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Identifier of the deployment to request the backups for.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Request backups that are created at or after this timestamp.
	// This is an optional field.
	From *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// Request backups that are created before this timestamp.
	// This is an optional field.
	To *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// If set, only backups that can be recovered from are included in the result.
	// A backup can be recovered from when:
	// - It is available and restorable on the servers of the deployment or
	// - It is uploaded and the upload has finised.
	GoodOnly bool `protobuf:"varint,4,opt,name=good_only,json=goodOnly,proto3" json:"good_only,omitempty"`
	// Optional common list options, the context_id is ignored
	Options *v1.ListOptions `protobuf:"bytes,10,opt,name=options,proto3" json:"options,omitempty"`
	// If set, the results will be sorted by created timestamp.
	SortByCreated bool `protobuf:"varint,20,opt,name=sort_by_created,json=sortByCreated,proto3" json:"sort_by_created,omitempty"`
	// Sort descending (default is ascending).
	SortDescending bool `protobuf:"varint,21,opt,name=sort_descending,json=sortDescending,proto3" json:"sort_descending,omitempty"`
}

func (x *ListBackupsRequest) Reset() {
	*x = ListBackupsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListBackupsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListBackupsRequest) ProtoMessage() {}

func (x *ListBackupsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListBackupsRequest.ProtoReflect.Descriptor instead.
func (*ListBackupsRequest) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{6}
}

func (x *ListBackupsRequest) GetDeploymentId() string {
	if x != nil {
		return x.DeploymentId
	}
	return ""
}

func (x *ListBackupsRequest) GetFrom() *timestamppb.Timestamp {
	if x != nil {
		return x.From
	}
	return nil
}

func (x *ListBackupsRequest) GetTo() *timestamppb.Timestamp {
	if x != nil {
		return x.To
	}
	return nil
}

func (x *ListBackupsRequest) GetGoodOnly() bool {
	if x != nil {
		return x.GoodOnly
	}
	return false
}

func (x *ListBackupsRequest) GetOptions() *v1.ListOptions {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *ListBackupsRequest) GetSortByCreated() bool {
	if x != nil {
		return x.SortByCreated
	}
	return false
}

func (x *ListBackupsRequest) GetSortDescending() bool {
	if x != nil {
		return x.SortDescending
	}
	return false
}

// Parameters for copying the backup
type CopyBackupRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Identifier of the backup that is to be copied
	// The source backup should have the 'upload' boolean set.
	SourceBackupId string `protobuf:"bytes,1,opt,name=source_backup_id,json=sourceBackupId,proto3" json:"source_backup_id,omitempty"`
	// Identifier of the region where the backup should be copied
	RegionId string `protobuf:"bytes,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
}

func (x *CopyBackupRequest) Reset() {
	*x = CopyBackupRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CopyBackupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CopyBackupRequest) ProtoMessage() {}

func (x *CopyBackupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CopyBackupRequest.ProtoReflect.Descriptor instead.
func (*CopyBackupRequest) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{7}
}

func (x *CopyBackupRequest) GetSourceBackupId() string {
	if x != nil {
		return x.SourceBackupId
	}
	return ""
}

func (x *CopyBackupRequest) GetRegionId() string {
	if x != nil {
		return x.RegionId
	}
	return ""
}

type BackupPolicy_Schedule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Schedule type should be one of the following string: "Hourly|Daily|Monthly"
	// The schedule_hourly, schedule_daily or schedule_montly field should be set
	// Setting multiple fields, or inconsistent with this field result in an error during create/update
	ScheduleType string `protobuf:"bytes,1,opt,name=schedule_type,json=scheduleType,proto3" json:"schedule_type,omitempty"`
	// Schedule applies to the selected day of the week
	// This is applicable for Hourly type only, ignored for Daily and Monthly
	HourlySchedule *BackupPolicy_HourlySchedule `protobuf:"bytes,2,opt,name=hourly_schedule,json=hourlySchedule,proto3" json:"hourly_schedule,omitempty"`
	// Schedule applies to the selected day of the week
	// This is applicable for Daily type only, ignored for Hourly and Monthly
	DailySchedule *BackupPolicy_DailySchedule `protobuf:"bytes,3,opt,name=daily_schedule,json=dailySchedule,proto3" json:"daily_schedule,omitempty"`
	// Schedule applies to the selected day of the month
	// This is applicable for Monthly type only, ignored for Hourly and Daily
	MonthlySchedule *BackupPolicy_MonthlySchedule `protobuf:"bytes,4,opt,name=monthly_schedule,json=monthlySchedule,proto3" json:"monthly_schedule,omitempty"`
}

func (x *BackupPolicy_Schedule) Reset() {
	*x = BackupPolicy_Schedule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BackupPolicy_Schedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupPolicy_Schedule) ProtoMessage() {}

func (x *BackupPolicy_Schedule) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupPolicy_Schedule.ProtoReflect.Descriptor instead.
func (*BackupPolicy_Schedule) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{0, 0}
}

func (x *BackupPolicy_Schedule) GetScheduleType() string {
	if x != nil {
		return x.ScheduleType
	}
	return ""
}

func (x *BackupPolicy_Schedule) GetHourlySchedule() *BackupPolicy_HourlySchedule {
	if x != nil {
		return x.HourlySchedule
	}
	return nil
}

func (x *BackupPolicy_Schedule) GetDailySchedule() *BackupPolicy_DailySchedule {
	if x != nil {
		return x.DailySchedule
	}
	return nil
}

func (x *BackupPolicy_Schedule) GetMonthlySchedule() *BackupPolicy_MonthlySchedule {
	if x != nil {
		return x.MonthlySchedule
	}
	return nil
}

// Note: Nested types inside nested types is not supported by the typescript generator
type BackupPolicy_HourlySchedule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Schedule should run with an interval of the specified hours (1-23)
	ScheduleEveryIntervalHours int32 `protobuf:"varint,1,opt,name=schedule_every_interval_hours,json=scheduleEveryIntervalHours,proto3" json:"schedule_every_interval_hours,omitempty"`
	// Minutes offset is a minute offset to full hour (0-59) when the backup process should start
	MinutesOffset int32 `protobuf:"varint,2,opt,name=minutes_offset,json=minutesOffset,proto3" json:"minutes_offset,omitempty"`
}

func (x *BackupPolicy_HourlySchedule) Reset() {
	*x = BackupPolicy_HourlySchedule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BackupPolicy_HourlySchedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupPolicy_HourlySchedule) ProtoMessage() {}

func (x *BackupPolicy_HourlySchedule) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupPolicy_HourlySchedule.ProtoReflect.Descriptor instead.
func (*BackupPolicy_HourlySchedule) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{0, 1}
}

func (x *BackupPolicy_HourlySchedule) GetScheduleEveryIntervalHours() int32 {
	if x != nil {
		return x.ScheduleEveryIntervalHours
	}
	return 0
}

func (x *BackupPolicy_HourlySchedule) GetMinutesOffset() int32 {
	if x != nil {
		return x.MinutesOffset
	}
	return 0
}

// Note: Nested types inside nested types is not supported by the typescript generator
type BackupPolicy_DailySchedule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If set, a backup will be created on Mondays.
	Monday bool `protobuf:"varint,1,opt,name=monday,proto3" json:"monday,omitempty"`
	// If set, a backup will be created on Tuesdays.
	Tuesday bool `protobuf:"varint,2,opt,name=tuesday,proto3" json:"tuesday,omitempty"`
	// If set, a backup will be created on Wednesdays.
	Wednesday bool `protobuf:"varint,3,opt,name=wednesday,proto3" json:"wednesday,omitempty"`
	// If set, a backup will be created on Thursdays.
	Thursday bool `protobuf:"varint,4,opt,name=thursday,proto3" json:"thursday,omitempty"`
	// If set, a backup will be created on Fridays.
	Friday bool `protobuf:"varint,5,opt,name=friday,proto3" json:"friday,omitempty"`
	// If set, a backup will be created on Saturdays.
	Saturday bool `protobuf:"varint,6,opt,name=saturday,proto3" json:"saturday,omitempty"`
	// If set, a backup will be created on Sundays.
	Sunday bool `protobuf:"varint,7,opt,name=sunday,proto3" json:"sunday,omitempty"`
	// The (target) time of the schedule
	ScheduleAt *TimeOfDay `protobuf:"bytes,10,opt,name=schedule_at,json=scheduleAt,proto3" json:"schedule_at,omitempty"`
}

func (x *BackupPolicy_DailySchedule) Reset() {
	*x = BackupPolicy_DailySchedule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BackupPolicy_DailySchedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupPolicy_DailySchedule) ProtoMessage() {}

func (x *BackupPolicy_DailySchedule) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupPolicy_DailySchedule.ProtoReflect.Descriptor instead.
func (*BackupPolicy_DailySchedule) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{0, 2}
}

func (x *BackupPolicy_DailySchedule) GetMonday() bool {
	if x != nil {
		return x.Monday
	}
	return false
}

func (x *BackupPolicy_DailySchedule) GetTuesday() bool {
	if x != nil {
		return x.Tuesday
	}
	return false
}

func (x *BackupPolicy_DailySchedule) GetWednesday() bool {
	if x != nil {
		return x.Wednesday
	}
	return false
}

func (x *BackupPolicy_DailySchedule) GetThursday() bool {
	if x != nil {
		return x.Thursday
	}
	return false
}

func (x *BackupPolicy_DailySchedule) GetFriday() bool {
	if x != nil {
		return x.Friday
	}
	return false
}

func (x *BackupPolicy_DailySchedule) GetSaturday() bool {
	if x != nil {
		return x.Saturday
	}
	return false
}

func (x *BackupPolicy_DailySchedule) GetSunday() bool {
	if x != nil {
		return x.Sunday
	}
	return false
}

func (x *BackupPolicy_DailySchedule) GetScheduleAt() *TimeOfDay {
	if x != nil {
		return x.ScheduleAt
	}
	return nil
}

// Note: Nested types inside nested types is not supported by the typescript generator
type BackupPolicy_MonthlySchedule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Run the backup on the specified day of the month (1-31)
	// Note: Specifying a number larger than some months have days will result in no backup for those months (e.g. 29 for February (unless leap year)).
	DayOfMonth int32 `protobuf:"varint,1,opt,name=day_of_month,json=dayOfMonth,proto3" json:"day_of_month,omitempty"`
	// The (target) time of the schedule
	ScheduleAt *TimeOfDay `protobuf:"bytes,10,opt,name=schedule_at,json=scheduleAt,proto3" json:"schedule_at,omitempty"`
}

func (x *BackupPolicy_MonthlySchedule) Reset() {
	*x = BackupPolicy_MonthlySchedule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BackupPolicy_MonthlySchedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupPolicy_MonthlySchedule) ProtoMessage() {}

func (x *BackupPolicy_MonthlySchedule) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupPolicy_MonthlySchedule.ProtoReflect.Descriptor instead.
func (*BackupPolicy_MonthlySchedule) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{0, 3}
}

func (x *BackupPolicy_MonthlySchedule) GetDayOfMonth() int32 {
	if x != nil {
		return x.DayOfMonth
	}
	return 0
}

func (x *BackupPolicy_MonthlySchedule) GetScheduleAt() *TimeOfDay {
	if x != nil {
		return x.ScheduleAt
	}
	return nil
}

// Status of the backup policy
// All members of this field are read-only.
type BackupPolicy_Status struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The timestamp when the next backup - initiated by this backup policy - will be created
	NextBackup *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=next_backup,json=nextBackup,proto3" json:"next_backup,omitempty"`
	// Message in case of failure, otherwise an empty string
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *BackupPolicy_Status) Reset() {
	*x = BackupPolicy_Status{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BackupPolicy_Status) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackupPolicy_Status) ProtoMessage() {}

func (x *BackupPolicy_Status) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackupPolicy_Status.ProtoReflect.Descriptor instead.
func (*BackupPolicy_Status) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{0, 4}
}

func (x *BackupPolicy_Status) GetNextBackup() *timestamppb.Timestamp {
	if x != nil {
		return x.NextBackup
	}
	return nil
}

func (x *BackupPolicy_Status) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// Information about the deployment during backup
// All members of this field are read-only.
type Backup_DeploymentInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// ArangoDB version of the deployment during backup.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Servers spec of the deployment during backup.
	Servers *v11.Deployment_ServersSpec `protobuf:"bytes,2,opt,name=servers,proto3" json:"servers,omitempty"`
	// Model of the deployment during backup.
	Model *v11.Deployment_ModelSpec `protobuf:"bytes,3,opt,name=model,proto3" json:"model,omitempty"`
}

func (x *Backup_DeploymentInfo) Reset() {
	*x = Backup_DeploymentInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Backup_DeploymentInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backup_DeploymentInfo) ProtoMessage() {}

func (x *Backup_DeploymentInfo) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backup_DeploymentInfo.ProtoReflect.Descriptor instead.
func (*Backup_DeploymentInfo) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{4, 0}
}

func (x *Backup_DeploymentInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Backup_DeploymentInfo) GetServers() *v11.Deployment_ServersSpec {
	if x != nil {
		return x.Servers
	}
	return nil
}

func (x *Backup_DeploymentInfo) GetModel() *v11.Deployment_ModelSpec {
	if x != nil {
		return x.Model
	}
	return nil
}

// Information about a backup download.
// All members of this message are read-only.
type Backup_DownloadSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The revision of this DownloadSpec
	Revision int32 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// The timestamp of when the last revision has been updated.
	LastUpdatedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
}

func (x *Backup_DownloadSpec) Reset() {
	*x = Backup_DownloadSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Backup_DownloadSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backup_DownloadSpec) ProtoMessage() {}

func (x *Backup_DownloadSpec) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backup_DownloadSpec.ProtoReflect.Descriptor instead.
func (*Backup_DownloadSpec) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{4, 1}
}

func (x *Backup_DownloadSpec) GetRevision() int32 {
	if x != nil {
		return x.Revision
	}
	return 0
}

func (x *Backup_DownloadSpec) GetLastUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUpdatedAt
	}
	return nil
}

// Status of the actual backup
// All members of this field are read-only.
type Backup_Status struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The creation timestamp of the backup
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// ArangoDB version of the backup
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// The state of the backup
	// Will be one of the following: "Pending|Unavailable|Scheduled|Download|DownloadError|Downloading|Create|Upload|Uploading|UploadError|Ready|Deleted|Failed"
	State string `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	// Set when the backup is failed
	IsFailed bool `protobuf:"varint,4,opt,name=is_failed,json=isFailed,proto3" json:"is_failed,omitempty"`
	// State message
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// Progress of the backup (upload or download)
	Progress string `protobuf:"bytes,6,opt,name=progress,proto3" json:"progress,omitempty"`
	// Size of the backup (in bytes)
	SizeBytes int64 `protobuf:"varint,7,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// If set the backup is available on the cluster and can be restored
	Available bool `protobuf:"varint,10,opt,name=available,proto3" json:"available,omitempty"`
	// Number of dbservers of the deployment during backup
	Dbservers int32 `protobuf:"varint,11,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Indicates that the backup is available in the external source only.
	// You should download the backup before you can restore it.
	UploadOnly bool `protobuf:"varint,12,opt,name=upload_only,json=uploadOnly,proto3" json:"upload_only,omitempty"`
	// The status of backup upload (if applicable).
	UploadStatus *Backup_UploadStatus `protobuf:"bytes,100,opt,name=upload_status,json=uploadStatus,proto3" json:"upload_status,omitempty"`
	// The status of backup download (if applicable).
	// This field will be set to empty if a new revision of the spec is available
	DownloadStatus *Backup_DownloadStatus `protobuf:"bytes,101,opt,name=download_status,json=downloadStatus,proto3" json:"download_status,omitempty"`
}

func (x *Backup_Status) Reset() {
	*x = Backup_Status{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Backup_Status) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backup_Status) ProtoMessage() {}

func (x *Backup_Status) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backup_Status.ProtoReflect.Descriptor instead.
func (*Backup_Status) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{4, 2}
}

func (x *Backup_Status) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Backup_Status) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Backup_Status) GetState() string {
	if x != nil {
		return x.State
	}
	return ""
}

func (x *Backup_Status) GetIsFailed() bool {
	if x != nil {
		return x.IsFailed
	}
	return false
}

func (x *Backup_Status) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *Backup_Status) GetProgress() string {
	if x != nil {
		return x.Progress
	}
	return ""
}

func (x *Backup_Status) GetSizeBytes() int64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *Backup_Status) GetAvailable() bool {
	if x != nil {
		return x.Available
	}
	return false
}

func (x *Backup_Status) GetDbservers() int32 {
	if x != nil {
		return x.Dbservers
	}
	return 0
}

func (x *Backup_Status) GetUploadOnly() bool {
	if x != nil {
		return x.UploadOnly
	}
	return false
}

func (x *Backup_Status) GetUploadStatus() *Backup_UploadStatus {
	if x != nil {
		return x.UploadStatus
	}
	return nil
}

func (x *Backup_Status) GetDownloadStatus() *Backup_DownloadStatus {
	if x != nil {
		return x.DownloadStatus
	}
	return nil
}

// The status of backup upload
// All members of this message are read-only.
type Backup_UploadStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Set when the backup has been fully uploaded
	Uploaded bool `protobuf:"varint,1,opt,name=uploaded,proto3" json:"uploaded,omitempty"`
	// The timestamp of when the backup has been fully uploaded
	UploadedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=uploaded_at,json=uploadedAt,proto3" json:"uploaded_at,omitempty"`
	// Size of the backup in the external source (in bytes)
	SizeBytes int64 `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
}

func (x *Backup_UploadStatus) Reset() {
	*x = Backup_UploadStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Backup_UploadStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backup_UploadStatus) ProtoMessage() {}

func (x *Backup_UploadStatus) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backup_UploadStatus.ProtoReflect.Descriptor instead.
func (*Backup_UploadStatus) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{4, 3}
}

func (x *Backup_UploadStatus) GetUploaded() bool {
	if x != nil {
		return x.Uploaded
	}
	return false
}

func (x *Backup_UploadStatus) GetUploadedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UploadedAt
	}
	return nil
}

func (x *Backup_UploadStatus) GetSizeBytes() int64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

// The status of backup download
// All members of this message are read-only.
type Backup_DownloadStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The revision of the used DownloadStatus
	Revision int32 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// Set when the backup has been fully downloaded
	Downloaded bool `protobuf:"varint,2,opt,name=downloaded,proto3" json:"downloaded,omitempty"`
	// The timestamp of when the backup has been fully downloaded.
	DownloadedAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=downloaded_at,json=downloadedAt,proto3" json:"downloaded_at,omitempty"`
}

func (x *Backup_DownloadStatus) Reset() {
	*x = Backup_DownloadStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_backup_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Backup_DownloadStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Backup_DownloadStatus) ProtoMessage() {}

func (x *Backup_DownloadStatus) ProtoReflect() protoreflect.Message {
	mi := &file_backup_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Backup_DownloadStatus.ProtoReflect.Descriptor instead.
func (*Backup_DownloadStatus) Descriptor() ([]byte, []int) {
	return file_backup_proto_rawDescGZIP(), []int{4, 4}
}

func (x *Backup_DownloadStatus) GetRevision() int32 {
	if x != nil {
		return x.Revision
	}
	return 0
}

func (x *Backup_DownloadStatus) GetDownloaded() bool {
	if x != nil {
		return x.Downloaded
	}
	return false
}

func (x *Backup_DownloadStatus) GetDownloadedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.DownloadedAt
	}
	return nil
}

var File_backup_proto protoreflect.FileDescriptor

var file_backup_proto_rawDesc = []byte{
	0x0a, 0x0c, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x18,
	0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62,
	0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x1a, 0x12, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x76,
	0x31, 0x2f, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x16, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x61, 0x70,
	0x69, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0xe4, 0x0c, 0x0a, 0x0c, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x02, 0x69, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65,
	0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x0a, 0x0d,
	0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0c, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49,
	0x64, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x39, 0x0a, 0x0a,
	0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x64, 0x65,
	0x6c, 0x65, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x64, 0x65,
	0x6c, 0x65, 0x74, 0x65, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x44,
	0x65, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x70, 0x61, 0x75,
	0x73, 0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x50, 0x61, 0x75,
	0x73, 0x65, 0x64, 0x12, 0x4b, 0x0a, 0x08, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x18,
	0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62,
	0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31,
	0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x53, 0x63,
	0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x52, 0x08, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x12, 0x16, 0x0a, 0x06, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x06, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x44, 0x0a, 0x10, 0x72, 0x65, 0x74, 0x65,
	0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x18, 0x0c, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0f, 0x72,
	0x65, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x12, 0x2d,
	0x0a, 0x12, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x5f, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x65, 0x6d, 0x61, 0x69,
	0x6c, 0x4e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a,
	0x06, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x6c,
	0x6f, 0x63, 0x6b, 0x65, 0x64, 0x12, 0x45, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18,
	0x64, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62,
	0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31,
	0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x32, 0x0a, 0x15,
	0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x72, 0x65, 0x67, 0x69, 0x6f,
	0x6e, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x65, 0x20, 0x03, 0x28, 0x09, 0x52, 0x13, 0x61, 0x64, 0x64,
	0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x52, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x73,
	0x1a, 0xcf, 0x02, 0x0a, 0x08, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x12, 0x23, 0x0a,
	0x0d, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x54, 0x79,
	0x70, 0x65, 0x12, 0x5e, 0x0a, 0x0f, 0x68, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x5f, 0x73, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x61, 0x72,
	0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63,
	0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x2e, 0x48, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x52, 0x0e, 0x68, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x12, 0x5b, 0x0a, 0x0e, 0x64, 0x61, 0x69, 0x6c, 0x79, 0x5f, 0x73, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x61, 0x72, 0x61,
	0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b,
	0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x2e, 0x44, 0x61, 0x69, 0x6c, 0x79, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x52, 0x0d, 0x64, 0x61, 0x69, 0x6c, 0x79, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x12,
	0x61, 0x0a, 0x10, 0x6d, 0x6f, 0x6e, 0x74, 0x68, 0x6c, 0x79, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x64,
	0x75, 0x6c, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x36, 0x2e, 0x61, 0x72, 0x61, 0x6e,
	0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75,
	0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x2e, 0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x6c, 0x79, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
	0x65, 0x52, 0x0f, 0x6d, 0x6f, 0x6e, 0x74, 0x68, 0x6c, 0x79, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75,
	0x6c, 0x65, 0x1a, 0x7a, 0x0a, 0x0e, 0x48, 0x6f, 0x75, 0x72, 0x6c, 0x79, 0x53, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x12, 0x41, 0x0a, 0x1d, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x5f, 0x65, 0x76, 0x65, 0x72, 0x79, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x5f,
	0x68, 0x6f, 0x75, 0x72, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x1a, 0x73, 0x63, 0x68,
	0x65, 0x64, 0x75, 0x6c, 0x65, 0x45, 0x76, 0x65, 0x72, 0x79, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76,
	0x61, 0x6c, 0x48, 0x6f, 0x75, 0x72, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x75, 0x74,
	0x65, 0x73, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52,
	0x0d, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x1a, 0x8d,
	0x02, 0x0a, 0x0d, 0x44, 0x61, 0x69, 0x6c, 0x79, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
	0x12, 0x16, 0x0a, 0x06, 0x6d, 0x6f, 0x6e, 0x64, 0x61, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x06, 0x6d, 0x6f, 0x6e, 0x64, 0x61, 0x79, 0x12, 0x18, 0x0a, 0x07, 0x74, 0x75, 0x65, 0x73,
	0x64, 0x61, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x74, 0x75, 0x65, 0x73, 0x64,
	0x61, 0x79, 0x12, 0x1c, 0x0a, 0x09, 0x77, 0x65, 0x64, 0x6e, 0x65, 0x73, 0x64, 0x61, 0x79, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x77, 0x65, 0x64, 0x6e, 0x65, 0x73, 0x64, 0x61, 0x79,
	0x12, 0x1a, 0x0a, 0x08, 0x74, 0x68, 0x75, 0x72, 0x73, 0x64, 0x61, 0x79, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x08, 0x74, 0x68, 0x75, 0x72, 0x73, 0x64, 0x61, 0x79, 0x12, 0x16, 0x0a, 0x06,
	0x66, 0x72, 0x69, 0x64, 0x61, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x66, 0x72,
	0x69, 0x64, 0x61, 0x79, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x61, 0x74, 0x75, 0x72, 0x64, 0x61, 0x79,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x73, 0x61, 0x74, 0x75, 0x72, 0x64, 0x61, 0x79,
	0x12, 0x16, 0x0a, 0x06, 0x73, 0x75, 0x6e, 0x64, 0x61, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x06, 0x73, 0x75, 0x6e, 0x64, 0x61, 0x79, 0x12, 0x44, 0x0a, 0x0b, 0x73, 0x63, 0x68, 0x65,
	0x64, 0x75, 0x6c, 0x65, 0x5f, 0x61, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e,
	0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62,
	0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x4f, 0x66, 0x44,
	0x61, 0x79, 0x52, 0x0a, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x41, 0x74, 0x1a, 0x79,
	0x0a, 0x0f, 0x4d, 0x6f, 0x6e, 0x74, 0x68, 0x6c, 0x79, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
	0x65, 0x12, 0x20, 0x0a, 0x0c, 0x64, 0x61, 0x79, 0x5f, 0x6f, 0x66, 0x5f, 0x6d, 0x6f, 0x6e, 0x74,
	0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x64, 0x61, 0x79, 0x4f, 0x66, 0x4d, 0x6f,
	0x6e, 0x74, 0x68, 0x12, 0x44, 0x0a, 0x0b, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x5f,
	0x61, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67,
	0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x2e, 0x76, 0x31, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x4f, 0x66, 0x44, 0x61, 0x79, 0x52, 0x0a, 0x73,
	0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x41, 0x74, 0x1a, 0x5f, 0x0a, 0x06, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x3b, 0x0a, 0x0b, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x62, 0x61, 0x63, 0x6b,
	0x75, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x6e, 0x65, 0x78, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x58, 0x0a, 0x09, 0x54, 0x69,
	0x6d, 0x65, 0x4f, 0x66, 0x44, 0x61, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x68, 0x6f, 0x75, 0x72, 0x73,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x68, 0x6f, 0x75, 0x72, 0x73, 0x12, 0x18, 0x0a,
	0x07, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07,
	0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x5f,
	0x7a, 0x6f, 0x6e, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x69, 0x6d, 0x65,
	0x5a, 0x6f, 0x6e, 0x65, 0x22, 0x8a, 0x01, 0x0a, 0x10, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x3c, 0x0a, 0x05, 0x69, 0x74, 0x65,
	0x6d, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67,
	0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x38, 0x0a, 0x06, 0x62, 0x75, 0x64, 0x67, 0x65,
	0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f,
	0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x42, 0x75, 0x64, 0x67, 0x65, 0x74, 0x52, 0x06, 0x62, 0x75, 0x64, 0x67, 0x65,
	0x74, 0x22, 0xaa, 0x01, 0x0a, 0x19, 0x4c, 0x69, 0x73, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x23, 0x0a, 0x0d, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65,
	0x6e, 0x74, 0x49, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f,
	0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x69,
	0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x12, 0x3f, 0x0a,
	0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25,
	0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e,
	0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0xf0,
	0x0e, 0x0a, 0x06, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
	0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f,
	0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79,
	0x6d, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x28, 0x0a, 0x10, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x5f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x49, 0x64,
	0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x07,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x39, 0x0a, 0x0a, 0x64,
	0x65, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x64, 0x65, 0x6c,
	0x65, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x64, 0x65, 0x6c,
	0x65, 0x74, 0x65, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x44, 0x65,
	0x6c, 0x65, 0x74, 0x65, 0x64, 0x12, 0x42, 0x0a, 0x0f, 0x61, 0x75, 0x74, 0x6f, 0x5f, 0x64, 0x65,
	0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
	0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0d, 0x61, 0x75, 0x74, 0x6f,
	0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x58, 0x0a, 0x0f, 0x64, 0x65, 0x70,
	0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x0b, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61,
	0x63, 0x6b, 0x75, 0x70, 0x2e, 0x44, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49,
	0x6e, 0x66, 0x6f, 0x52, 0x0e, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49,
	0x6e, 0x66, 0x6f, 0x12, 0x16, 0x0a, 0x06, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x0c, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x06, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x46, 0x0a, 0x11, 0x75,
	0x70, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74,
	0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
	0x6d, 0x70, 0x52, 0x0f, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
	0x64, 0x41, 0x74, 0x12, 0x49, 0x0a, 0x08, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x18,
	0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62,
	0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31,
	0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64,
	0x53, 0x70, 0x65, 0x63, 0x52, 0x08, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x22,
	0x0a, 0x0d, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x5f, 0x69, 0x64, 0x18,
	0x0f, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x42, 0x79,
	0x49, 0x64, 0x12, 0x3f, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x64, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x27, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61,
	0x63, 0x6b, 0x75, 0x70, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64,
	0x18, 0x65, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x49, 0x64,
	0x12, 0x28, 0x0a, 0x10, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x62, 0x61, 0x63, 0x6b, 0x75,
	0x70, 0x5f, 0x69, 0x64, 0x18, 0x66, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x73, 0x6f, 0x75, 0x72,
	0x63, 0x65, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x49, 0x64, 0x1a, 0xb8, 0x01, 0x0a, 0x0e, 0x44,
	0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x18, 0x0a,
	0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x48, 0x0a, 0x07, 0x73, 0x65, 0x72, 0x76, 0x65,
	0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67,
	0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x76,
	0x31, 0x2e, 0x44, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x72,
	0x76, 0x65, 0x72, 0x73, 0x53, 0x70, 0x65, 0x63, 0x52, 0x07, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
	0x73, 0x12, 0x42, 0x0a, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2c, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75,
	0x64, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x70, 0x6c, 0x6f, 0x79,
	0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x53, 0x70, 0x65, 0x63, 0x52, 0x05,
	0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x1a, 0x6e, 0x0a, 0x0c, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61,
	0x64, 0x53, 0x70, 0x65, 0x63, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f,
	0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f,
	0x6e, 0x12, 0x42, 0x0a, 0x0f, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
	0x64, 0x5f, 0x61, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x64, 0x41, 0x74, 0x1a, 0xf0, 0x03, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x76,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65,
	0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x69,
	0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08,
	0x69, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x12, 0x1d,
	0x0a, 0x0a, 0x73, 0x69, 0x7a, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x07, 0x20, 0x01,
	0x28, 0x03, 0x52, 0x09, 0x73, 0x69, 0x7a, 0x65, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x1c, 0x0a,
	0x09, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x09, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x64,
	0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x05, 0x52, 0x09,
	0x64, 0x62, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x75, 0x70, 0x6c,
	0x6f, 0x61, 0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a,
	0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x52, 0x0a, 0x0d, 0x75, 0x70,
	0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x64, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2d, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f,
	0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63,
	0x6b, 0x75, 0x70, 0x2e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x52, 0x0c, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x58,
	0x0a, 0x0f, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x18, 0x65, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f,
	0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e,
	0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f,
	0x61, 0x64, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x0e, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f,
	0x61, 0x64, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x1a, 0x86, 0x01, 0x0a, 0x0c, 0x55, 0x70, 0x6c,
	0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x70, 0x6c,
	0x6f, 0x61, 0x64, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x75, 0x70, 0x6c,
	0x6f, 0x61, 0x64, 0x65, 0x64, 0x12, 0x3b, 0x0a, 0x0b, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x65,
	0x64, 0x5f, 0x61, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64,
	0x41, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x69, 0x7a, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x73, 0x69, 0x7a, 0x65, 0x42, 0x79, 0x74, 0x65,
	0x73, 0x1a, 0x8d, 0x01, 0x0a, 0x0e, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e,
	0x12, 0x1e, 0x0a, 0x0a, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64,
	0x12, 0x3f, 0x0a, 0x0d, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x5f, 0x61,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x52, 0x0c, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x41,
	0x74, 0x22, 0x7e, 0x0a, 0x0a, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x12,
	0x36, 0x0a, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20,
	0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e,
	0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x52, 0x05, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x38, 0x0a, 0x06, 0x62, 0x75, 0x64, 0x67, 0x65,
	0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f,
	0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x42, 0x75, 0x64, 0x67, 0x65, 0x74, 0x52, 0x06, 0x62, 0x75, 0x64, 0x67, 0x65,
	0x74, 0x22, 0xc4, 0x02, 0x0a, 0x12, 0x4c, 0x69, 0x73, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x64, 0x65, 0x70, 0x6c,
	0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0c, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x2e, 0x0a,
	0x04, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69,
	0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x2a, 0x0a,
	0x02, 0x74, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x02, 0x74, 0x6f, 0x12, 0x1b, 0x0a, 0x09, 0x67, 0x6f, 0x6f,
	0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x67, 0x6f,
	0x6f, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x3f, 0x0a, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f,
	0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x07,
	0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x26, 0x0a, 0x0f, 0x73, 0x6f, 0x72, 0x74, 0x5f,
	0x62, 0x79, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x14, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x0d, 0x73, 0x6f, 0x72, 0x74, 0x42, 0x79, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x12,
	0x27, 0x0a, 0x0f, 0x73, 0x6f, 0x72, 0x74, 0x5f, 0x64, 0x65, 0x73, 0x63, 0x65, 0x6e, 0x64, 0x69,
	0x6e, 0x67, 0x18, 0x15, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x73, 0x6f, 0x72, 0x74, 0x44, 0x65,
	0x73, 0x63, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x22, 0x5a, 0x0a, 0x11, 0x43, 0x6f, 0x70, 0x79,
	0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x28, 0x0a,
	0x10, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x5f, 0x69,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x42,
	0x61, 0x63, 0x6b, 0x75, 0x70, 0x49, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x67, 0x69, 0x6f,
	0x6e, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x67, 0x69,
	0x6f, 0x6e, 0x49, 0x64, 0x32, 0xa9, 0x13, 0x0a, 0x0d, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x53,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x77, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x41, 0x50, 0x49,
	0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f,
	0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x21, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67,
	0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x22, 0x82, 0xd3, 0xe4,
	0x93, 0x02, 0x1c, 0x12, 0x1a, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x2f, 0x76, 0x31, 0x2f, 0x61, 0x70, 0x69, 0x2d, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12,
	0x92, 0x01, 0x0a, 0x18, 0x49, 0x73, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x46, 0x65, 0x61, 0x74,
	0x75, 0x72, 0x65, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x23, 0x2e, 0x61,
	0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x44, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x1a, 0x21, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f,
	0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x59, 0x65, 0x73,
	0x4f, 0x72, 0x4e, 0x6f, 0x22, 0x2e, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x28, 0x12, 0x26, 0x2f, 0x61,
	0x70, 0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x70,
	0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x2f, 0x7b, 0x69, 0x64, 0x7d, 0x2f, 0x66, 0x65, 0x61,
	0x74, 0x75, 0x72, 0x65, 0x12, 0x9e, 0x01, 0x0a, 0x1e, 0x49, 0x73, 0x42, 0x61, 0x63, 0x6b, 0x75,
	0x70, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x41, 0x76,
	0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x23, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f,
	0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e,
	0x76, 0x31, 0x2e, 0x49, 0x44, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x21, 0x2e, 0x61,
	0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x59, 0x65, 0x73, 0x4f, 0x72, 0x4e, 0x6f, 0x22,
	0x34, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x2e, 0x12, 0x2c, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61,
	0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65,
	0x6e, 0x74, 0x2f, 0x7b, 0x69, 0x64, 0x7d, 0x2f, 0x75, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x66, 0x65,
	0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0xb4, 0x01, 0x0a, 0x29, 0x49, 0x73, 0x4d, 0x75, 0x6c, 0x74,
	0x69, 0x52, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x55, 0x70, 0x6c,
	0x6f, 0x61, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61,
	0x62, 0x6c, 0x65, 0x12, 0x23, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63,
	0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x49,
	0x44, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x21, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67,
	0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2e, 0x76, 0x31, 0x2e, 0x59, 0x65, 0x73, 0x4f, 0x72, 0x4e, 0x6f, 0x22, 0x3f, 0x82, 0xd3, 0xe4,
	0x93, 0x02, 0x39, 0x12, 0x37, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x2f, 0x7b,
	0x69, 0x64, 0x7d, 0x2f, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x75,
	0x70, 0x6c, 0x6f, 0x61, 0x64, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0xb7, 0x01, 0x0a,
	0x12, 0x4c, 0x69, 0x73, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x69, 0x65, 0x73, 0x12, 0x33, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63,
	0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x4c,
	0x69, 0x73, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65,
	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2a, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67,
	0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x4c, 0x69, 0x73, 0x74, 0x22, 0x40, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x3a, 0x12, 0x38, 0x2f, 0x61,
	0x70, 0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x70,
	0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x2f, 0x7b, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d,
	0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x12, 0x8a, 0x01, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x42, 0x61,
	0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x23, 0x2e, 0x61, 0x72, 0x61,
	0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x44, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a,
	0x26, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64,
	0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75,
	0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x22, 0x2a, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x24, 0x12,
	0x22, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f,
	0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x2f, 0x7b,
	0x69, 0x64, 0x7d, 0x12, 0xa9, 0x01, 0x0a, 0x12, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x42, 0x61,
	0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x26, 0x2e, 0x61, 0x72, 0x61,
	0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b,
	0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x1a, 0x26, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c,
	0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61,
	0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x22, 0x43, 0x82, 0xd3, 0xe4, 0x93,
	0x02, 0x3d, 0x3a, 0x01, 0x2a, 0x22, 0x38, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b,
	0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74,
	0x2f, 0x7b, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x7d,
	0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x12,
	0x93, 0x01, 0x0a, 0x12, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x26, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64,
	0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76,
	0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x1a, 0x26,
	0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e,
	0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x22, 0x2d, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x27, 0x3a, 0x01,
	0x2a, 0x32, 0x22, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76,
	0x31, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73,
	0x2f, 0x7b, 0x69, 0x64, 0x7d, 0x12, 0x86, 0x01, 0x0a, 0x12, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
	0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x23, 0x2e, 0x61,
	0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x44, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x1a, 0x1f, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f,
	0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x22, 0x2a, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x24, 0x2a, 0x22, 0x2f, 0x61, 0x70, 0x69,
	0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75,
	0x70, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x69, 0x65, 0x73, 0x2f, 0x7b, 0x69, 0x64, 0x7d, 0x12, 0x9c,
	0x01, 0x0a, 0x0b, 0x4c, 0x69, 0x73, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x73, 0x12, 0x2c,
	0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e,
	0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x42, 0x61,
	0x63, 0x6b, 0x75, 0x70, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x61,
	0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61,
	0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x4c, 0x69,
	0x73, 0x74, 0x22, 0x39, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x33, 0x12, 0x31, 0x2f, 0x61, 0x70, 0x69,
	0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x70, 0x6c, 0x6f,
	0x79, 0x6d, 0x65, 0x6e, 0x74, 0x2f, 0x7b, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e,
	0x74, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x73, 0x12, 0x76, 0x0a,
	0x09, 0x47, 0x65, 0x74, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x12, 0x23, 0x2e, 0x61, 0x72, 0x61,
	0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x44, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a,
	0x20, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64,
	0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75,
	0x70, 0x22, 0x22, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1c, 0x12, 0x1a, 0x2f, 0x61, 0x70, 0x69, 0x2f,
	0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x2f, 0x7b, 0x69, 0x64, 0x7d, 0x12, 0x8f, 0x01, 0x0a, 0x0c, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x12, 0x20, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64,
	0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76,
	0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x1a, 0x20, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67,
	0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x22, 0x3b, 0x82, 0xd3, 0xe4, 0x93,
	0x02, 0x35, 0x3a, 0x01, 0x2a, 0x22, 0x30, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b,
	0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74,
	0x2f, 0x7b, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x7d,
	0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x12, 0x79, 0x0a, 0x0c, 0x55, 0x70, 0x64, 0x61, 0x74,
	0x65, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x12, 0x20, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f,
	0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e,
	0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x1a, 0x20, 0x2e, 0x61, 0x72, 0x61, 0x6e,
	0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75,
	0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x22, 0x25, 0x82, 0xd3, 0xe4,
	0x93, 0x02, 0x1f, 0x3a, 0x01, 0x2a, 0x32, 0x1a, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x63,
	0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x7b, 0x69,
	0x64, 0x7d, 0x12, 0x83, 0x01, 0x0a, 0x0e, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x42,
	0x61, 0x63, 0x6b, 0x75, 0x70, 0x12, 0x23, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62,
	0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31,
	0x2e, 0x49, 0x44, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x1f, 0x2e, 0x61, 0x72, 0x61,
	0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x2b, 0x82, 0xd3, 0xe4,
	0x93, 0x02, 0x25, 0x22, 0x23, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70,
	0x2f, 0x76, 0x31, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x7b, 0x69, 0x64, 0x7d, 0x2f,
	0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x81, 0x01, 0x0a, 0x0d, 0x52, 0x65, 0x73,
	0x74, 0x6f, 0x72, 0x65, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x12, 0x23, 0x2e, 0x61, 0x72, 0x61,
	0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x44, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a,
	0x1f, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64,
	0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,
	0x22, 0x2a, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x24, 0x22, 0x22, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x62,
	0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f,
	0x7b, 0x69, 0x64, 0x7d, 0x2f, 0x72, 0x65, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x12, 0x78, 0x0a, 0x0c,
	0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x12, 0x23, 0x2e, 0x61,
	0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x63, 0x6f,
	0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x44, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x1a, 0x1f, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f,
	0x75, 0x64, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x6d, 0x70,
	0x74, 0x79, 0x22, 0x22, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1c, 0x2a, 0x1a, 0x2f, 0x61, 0x70, 0x69,
	0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75,
	0x70, 0x2f, 0x7b, 0x69, 0x64, 0x7d, 0x12, 0x78, 0x0a, 0x0a, 0x43, 0x6f, 0x70, 0x79, 0x42, 0x61,
	0x63, 0x6b, 0x75, 0x70, 0x12, 0x2b, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e,
	0x63, 0x6c, 0x6f, 0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e,
	0x43, 0x6f, 0x70, 0x79, 0x42, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x20, 0x2e, 0x61, 0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2e, 0x63, 0x6c, 0x6f,
	0x75, 0x64, 0x2e, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63,
	0x6b, 0x75, 0x70, 0x22, 0x1b, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x15, 0x22, 0x13, 0x2f, 0x61, 0x70,
	0x69, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x6f, 0x70, 0x79,
	0x42, 0x2c, 0x5a, 0x2a, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x61,
	0x72, 0x61, 0x6e, 0x67, 0x6f, 0x64, 0x62, 0x2d, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x64, 0x2f,
	0x61, 0x70, 0x69, 0x73, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x75, 0x70, 0x2f, 0x76, 0x31, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_backup_proto_rawDescOnce sync.Once
	file_backup_proto_rawDescData = file_backup_proto_rawDesc
)

func file_backup_proto_rawDescGZIP() []byte {
	file_backup_proto_rawDescOnce.Do(func() {
		file_backup_proto_rawDescData = protoimpl.X.CompressGZIP(file_backup_proto_rawDescData)
	})
	return file_backup_proto_rawDescData
}

var file_backup_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_backup_proto_goTypes = []interface{}{
	(*BackupPolicy)(nil),                 // 0: arangodb.cloud.backup.v1.BackupPolicy
	(*TimeOfDay)(nil),                    // 1: arangodb.cloud.backup.v1.TimeOfDay
	(*BackupPolicyList)(nil),             // 2: arangodb.cloud.backup.v1.BackupPolicyList
	(*ListBackupPoliciesRequest)(nil),    // 3: arangodb.cloud.backup.v1.ListBackupPoliciesRequest
	(*Backup)(nil),                       // 4: arangodb.cloud.backup.v1.Backup
	(*BackupList)(nil),                   // 5: arangodb.cloud.backup.v1.BackupList
	(*ListBackupsRequest)(nil),           // 6: arangodb.cloud.backup.v1.ListBackupsRequest
	(*CopyBackupRequest)(nil),            // 7: arangodb.cloud.backup.v1.CopyBackupRequest
	(*BackupPolicy_Schedule)(nil),        // 8: arangodb.cloud.backup.v1.BackupPolicy.Schedule
	(*BackupPolicy_HourlySchedule)(nil),  // 9: arangodb.cloud.backup.v1.BackupPolicy.HourlySchedule
	(*BackupPolicy_DailySchedule)(nil),   // 10: arangodb.cloud.backup.v1.BackupPolicy.DailySchedule
	(*BackupPolicy_MonthlySchedule)(nil), // 11: arangodb.cloud.backup.v1.BackupPolicy.MonthlySchedule
	(*BackupPolicy_Status)(nil),          // 12: arangodb.cloud.backup.v1.BackupPolicy.Status
	(*Backup_DeploymentInfo)(nil),        // 13: arangodb.cloud.backup.v1.Backup.DeploymentInfo
	(*Backup_DownloadSpec)(nil),          // 14: arangodb.cloud.backup.v1.Backup.DownloadSpec
	(*Backup_Status)(nil),                // 15: arangodb.cloud.backup.v1.Backup.Status
	(*Backup_UploadStatus)(nil),          // 16: arangodb.cloud.backup.v1.Backup.UploadStatus
	(*Backup_DownloadStatus)(nil),        // 17: arangodb.cloud.backup.v1.Backup.DownloadStatus
	(*timestamppb.Timestamp)(nil),        // 18: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),          // 19: google.protobuf.Duration
	(*v1.Budget)(nil),                    // 20: arangodb.cloud.common.v1.Budget
	(*v1.ListOptions)(nil),               // 21: arangodb.cloud.common.v1.ListOptions
	(*v11.Deployment_ServersSpec)(nil),   // 22: arangodb.cloud.data.v1.Deployment.ServersSpec
	(*v11.Deployment_ModelSpec)(nil),     // 23: arangodb.cloud.data.v1.Deployment.ModelSpec
	(*v1.Empty)(nil),                     // 24: arangodb.cloud.common.v1.Empty
	(*v1.IDOptions)(nil),                 // 25: arangodb.cloud.common.v1.IDOptions
	(*v1.Version)(nil),                   // 26: arangodb.cloud.common.v1.Version
	(*v1.YesOrNo)(nil),                   // 27: arangodb.cloud.common.v1.YesOrNo
}
var file_backup_proto_depIdxs = []int32{
	18, // 0: arangodb.cloud.backup.v1.BackupPolicy.created_at:type_name -> google.protobuf.Timestamp
	18, // 1: arangodb.cloud.backup.v1.BackupPolicy.deleted_at:type_name -> google.protobuf.Timestamp
	8,  // 2: arangodb.cloud.backup.v1.BackupPolicy.schedule:type_name -> arangodb.cloud.backup.v1.BackupPolicy.Schedule
	19, // 3: arangodb.cloud.backup.v1.BackupPolicy.retention_period:type_name -> google.protobuf.Duration
	12, // 4: arangodb.cloud.backup.v1.BackupPolicy.status:type_name -> arangodb.cloud.backup.v1.BackupPolicy.Status
	0,  // 5: arangodb.cloud.backup.v1.BackupPolicyList.items:type_name -> arangodb.cloud.backup.v1.BackupPolicy
	20, // 6: arangodb.cloud.backup.v1.BackupPolicyList.budget:type_name -> arangodb.cloud.common.v1.Budget
	21, // 7: arangodb.cloud.backup.v1.ListBackupPoliciesRequest.options:type_name -> arangodb.cloud.common.v1.ListOptions
	18, // 8: arangodb.cloud.backup.v1.Backup.created_at:type_name -> google.protobuf.Timestamp
	18, // 9: arangodb.cloud.backup.v1.Backup.deleted_at:type_name -> google.protobuf.Timestamp
	18, // 10: arangodb.cloud.backup.v1.Backup.auto_deleted_at:type_name -> google.protobuf.Timestamp
	13, // 11: arangodb.cloud.backup.v1.Backup.deployment_info:type_name -> arangodb.cloud.backup.v1.Backup.DeploymentInfo
	18, // 12: arangodb.cloud.backup.v1.Backup.upload_updated_at:type_name -> google.protobuf.Timestamp
	14, // 13: arangodb.cloud.backup.v1.Backup.download:type_name -> arangodb.cloud.backup.v1.Backup.DownloadSpec
	15, // 14: arangodb.cloud.backup.v1.Backup.status:type_name -> arangodb.cloud.backup.v1.Backup.Status
	4,  // 15: arangodb.cloud.backup.v1.BackupList.items:type_name -> arangodb.cloud.backup.v1.Backup
	20, // 16: arangodb.cloud.backup.v1.BackupList.budget:type_name -> arangodb.cloud.common.v1.Budget
	18, // 17: arangodb.cloud.backup.v1.ListBackupsRequest.from:type_name -> google.protobuf.Timestamp
	18, // 18: arangodb.cloud.backup.v1.ListBackupsRequest.to:type_name -> google.protobuf.Timestamp
	21, // 19: arangodb.cloud.backup.v1.ListBackupsRequest.options:type_name -> arangodb.cloud.common.v1.ListOptions
	9,  // 20: arangodb.cloud.backup.v1.BackupPolicy.Schedule.hourly_schedule:type_name -> arangodb.cloud.backup.v1.BackupPolicy.HourlySchedule
	10, // 21: arangodb.cloud.backup.v1.BackupPolicy.Schedule.daily_schedule:type_name -> arangodb.cloud.backup.v1.BackupPolicy.DailySchedule
	11, // 22: arangodb.cloud.backup.v1.BackupPolicy.Schedule.monthly_schedule:type_name -> arangodb.cloud.backup.v1.BackupPolicy.MonthlySchedule
	1,  // 23: arangodb.cloud.backup.v1.BackupPolicy.DailySchedule.schedule_at:type_name -> arangodb.cloud.backup.v1.TimeOfDay
	1,  // 24: arangodb.cloud.backup.v1.BackupPolicy.MonthlySchedule.schedule_at:type_name -> arangodb.cloud.backup.v1.TimeOfDay
	18, // 25: arangodb.cloud.backup.v1.BackupPolicy.Status.next_backup:type_name -> google.protobuf.Timestamp
	22, // 26: arangodb.cloud.backup.v1.Backup.DeploymentInfo.servers:type_name -> arangodb.cloud.data.v1.Deployment.ServersSpec
	23, // 27: arangodb.cloud.backup.v1.Backup.DeploymentInfo.model:type_name -> arangodb.cloud.data.v1.Deployment.ModelSpec
	18, // 28: arangodb.cloud.backup.v1.Backup.DownloadSpec.last_updated_at:type_name -> google.protobuf.Timestamp
	18, // 29: arangodb.cloud.backup.v1.Backup.Status.created_at:type_name -> google.protobuf.Timestamp
	16, // 30: arangodb.cloud.backup.v1.Backup.Status.upload_status:type_name -> arangodb.cloud.backup.v1.Backup.UploadStatus
	17, // 31: arangodb.cloud.backup.v1.Backup.Status.download_status:type_name -> arangodb.cloud.backup.v1.Backup.DownloadStatus
	18, // 32: arangodb.cloud.backup.v1.Backup.UploadStatus.uploaded_at:type_name -> google.protobuf.Timestamp
	18, // 33: arangodb.cloud.backup.v1.Backup.DownloadStatus.downloaded_at:type_name -> google.protobuf.Timestamp
	24, // 34: arangodb.cloud.backup.v1.BackupService.GetAPIVersion:input_type -> arangodb.cloud.common.v1.Empty
	25, // 35: arangodb.cloud.backup.v1.BackupService.IsBackupFeatureAvailable:input_type -> arangodb.cloud.common.v1.IDOptions
	25, // 36: arangodb.cloud.backup.v1.BackupService.IsBackupUploadFeatureAvailable:input_type -> arangodb.cloud.common.v1.IDOptions
	25, // 37: arangodb.cloud.backup.v1.BackupService.IsMultiRegionBackupUploadFeatureAvailable:input_type -> arangodb.cloud.common.v1.IDOptions
	3,  // 38: arangodb.cloud.backup.v1.BackupService.ListBackupPolicies:input_type -> arangodb.cloud.backup.v1.ListBackupPoliciesRequest
	25, // 39: arangodb.cloud.backup.v1.BackupService.GetBackupPolicy:input_type -> arangodb.cloud.common.v1.IDOptions
	0,  // 40: arangodb.cloud.backup.v1.BackupService.CreateBackupPolicy:input_type -> arangodb.cloud.backup.v1.BackupPolicy
	0,  // 41: arangodb.cloud.backup.v1.BackupService.UpdateBackupPolicy:input_type -> arangodb.cloud.backup.v1.BackupPolicy
	25, // 42: arangodb.cloud.backup.v1.BackupService.DeleteBackupPolicy:input_type -> arangodb.cloud.common.v1.IDOptions
	6,  // 43: arangodb.cloud.backup.v1.BackupService.ListBackups:input_type -> arangodb.cloud.backup.v1.ListBackupsRequest
	25, // 44: arangodb.cloud.backup.v1.BackupService.GetBackup:input_type -> arangodb.cloud.common.v1.IDOptions
	4,  // 45: arangodb.cloud.backup.v1.BackupService.CreateBackup:input_type -> arangodb.cloud.backup.v1.Backup
	4,  // 46: arangodb.cloud.backup.v1.BackupService.UpdateBackup:input_type -> arangodb.cloud.backup.v1.Backup
	25, // 47: arangodb.cloud.backup.v1.BackupService.DownloadBackup:input_type -> arangodb.cloud.common.v1.IDOptions
	25, // 48: arangodb.cloud.backup.v1.BackupService.RestoreBackup:input_type -> arangodb.cloud.common.v1.IDOptions
	25, // 49: arangodb.cloud.backup.v1.BackupService.DeleteBackup:input_type -> arangodb.cloud.common.v1.IDOptions
	7,  // 50: arangodb.cloud.backup.v1.BackupService.CopyBackup:input_type -> arangodb.cloud.backup.v1.CopyBackupRequest
	26, // 51: arangodb.cloud.backup.v1.BackupService.GetAPIVersion:output_type -> arangodb.cloud.common.v1.Version
	27, // 52: arangodb.cloud.backup.v1.BackupService.IsBackupFeatureAvailable:output_type -> arangodb.cloud.common.v1.YesOrNo
	27, // 53: arangodb.cloud.backup.v1.BackupService.IsBackupUploadFeatureAvailable:output_type -> arangodb.cloud.common.v1.YesOrNo
	27, // 54: arangodb.cloud.backup.v1.BackupService.IsMultiRegionBackupUploadFeatureAvailable:output_type -> arangodb.cloud.common.v1.YesOrNo
	2,  // 55: arangodb.cloud.backup.v1.BackupService.ListBackupPolicies:output_type -> arangodb.cloud.backup.v1.BackupPolicyList
	0,  // 56: arangodb.cloud.backup.v1.BackupService.GetBackupPolicy:output_type -> arangodb.cloud.backup.v1.BackupPolicy
	0,  // 57: arangodb.cloud.backup.v1.BackupService.CreateBackupPolicy:output_type -> arangodb.cloud.backup.v1.BackupPolicy
	0,  // 58: arangodb.cloud.backup.v1.BackupService.UpdateBackupPolicy:output_type -> arangodb.cloud.backup.v1.BackupPolicy
	24, // 59: arangodb.cloud.backup.v1.BackupService.DeleteBackupPolicy:output_type -> arangodb.cloud.common.v1.Empty
	5,  // 60: arangodb.cloud.backup.v1.BackupService.ListBackups:output_type -> arangodb.cloud.backup.v1.BackupList
	4,  // 61: arangodb.cloud.backup.v1.BackupService.GetBackup:output_type -> arangodb.cloud.backup.v1.Backup
	4,  // 62: arangodb.cloud.backup.v1.BackupService.CreateBackup:output_type -> arangodb.cloud.backup.v1.Backup
	4,  // 63: arangodb.cloud.backup.v1.BackupService.UpdateBackup:output_type -> arangodb.cloud.backup.v1.Backup
	24, // 64: arangodb.cloud.backup.v1.BackupService.DownloadBackup:output_type -> arangodb.cloud.common.v1.Empty
	24, // 65: arangodb.cloud.backup.v1.BackupService.RestoreBackup:output_type -> arangodb.cloud.common.v1.Empty
	24, // 66: arangodb.cloud.backup.v1.BackupService.DeleteBackup:output_type -> arangodb.cloud.common.v1.Empty
	4,  // 67: arangodb.cloud.backup.v1.BackupService.CopyBackup:output_type -> arangodb.cloud.backup.v1.Backup
	51, // [51:68] is the sub-list for method output_type
	34, // [34:51] is the sub-list for method input_type
	34, // [34:34] is the sub-list for extension type_name
	34, // [34:34] is the sub-list for extension extendee
	0,  // [0:34] is the sub-list for field type_name
}

func init() { file_backup_proto_init() }
func file_backup_proto_init() {
	if File_backup_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_backup_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BackupPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TimeOfDay); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BackupPolicyList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListBackupPoliciesRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Backup); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BackupList); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListBackupsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CopyBackupRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BackupPolicy_Schedule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BackupPolicy_HourlySchedule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BackupPolicy_DailySchedule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BackupPolicy_MonthlySchedule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BackupPolicy_Status); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Backup_DeploymentInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Backup_DownloadSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Backup_Status); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Backup_UploadStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_backup_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Backup_DownloadStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_backup_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_backup_proto_goTypes,
		DependencyIndexes: file_backup_proto_depIdxs,
		MessageInfos:      file_backup_proto_msgTypes,
	}.Build()
	File_backup_proto = out.File
	file_backup_proto_rawDesc = nil
	file_backup_proto_goTypes = nil
	file_backup_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// BackupServiceClient is the client API for BackupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackupServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error)
	// Checks if the backup feature is enabled and available for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsBackupFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error)
	// Checks if the backup upload feature is enabled for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsBackupUploadFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error)
	// Checks if the multi region backup upload feature is enabled for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsMultiRegionBackupUploadFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error)
	// Fetch all backup policies for a specific deployment.
	// Required permissions:
	// - backup.backuppolicy.list on the deployment that owns the backup policies and is identified by the given ID.
	ListBackupPolicies(ctx context.Context, in *ListBackupPoliciesRequest, opts ...grpc.CallOption) (*BackupPolicyList, error)
	// Fetch a backup policy identified by the given ID.
	// Required permissions:
	// - backup.backuppolicy.get on the backup policy identified by the given ID.
	GetBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*BackupPolicy, error)
	// Create a new backup policy
	// Required permissions:
	// -  backup.backuppolicy.create on the deployment that owns the backup policy and is identified by the given ID.
	CreateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error)
	// Update a backup policy
	// Required permissions:
	// -  backup.backuppolicy.update on the backup policy identified by the given ID.
	UpdateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error)
	// Delete a backup policy identified by the given ID.
	// Note that the backup policy are initially only marked for deletion, no backups will be deleted with this operation.
	// Once all their dependent backups are removed, the backup policy is removed.
	// Required permissions:
	// -  backup.backuppolicy.delete on the backup policy identified by the given ID.
	DeleteBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Fetch all backups for a specific deployment.
	// Required permissions:
	// - backup.backup.list on the deployment that owns the backup and is identified by the given ID.
	ListBackups(ctx context.Context, in *ListBackupsRequest, opts ...grpc.CallOption) (*BackupList, error)
	// Fetch a backup identified by the given ID.
	// Required permissions:
	// - backup.backup.get on the backup identified by the given ID.
	GetBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Backup, error)
	// Create a new manual backup
	// Setting the backup_policy_id field in the backup is not allowed
	// Required permissions:
	// -  backup.backup.create on the deployment that owns the backup and is identified by the given ID.
	CreateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error)
	// Update a backup
	// Required permissions:
	// -  backup.backup.update on the backup identified by the given ID.
	UpdateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error)
	// Download a backup identified by the given ID from remote storage to the volumes of the servers of the deployment.
	// This operation can only be executed on backups which have the same number of DB Servers in the backup and the current running cluster.
	// If this backup was already downloaded, another download will be done.
	// If the backup is still available on the cluster there is no need to explicitly download the backup before restoring.
	// This function will return immediately.
	// To track status, please invoke GetBackup and check the .status field inside the returned backup object
	// Required permissions:
	// -  backup.backup.download on the backup identified by the given ID.
	DownloadBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Restore (or recover) a backup identified by the given ID
	// This operation can only be executed on backups where status.available is set and
	// the mayor and minor version of the backup and the current running cluster are the same.
	// This function will return immediately.
	// To track status, please invoke GetDeployment on the data API and check the
	// .status.restoring_backup and .status.restore_backup_status fields inside the returned deployment object
	// Required permissions (both are needed):
	// -  backup.backup.restore on the backup identified by the given ID.
	// -  data.deployment.restore-backup on the deployment that owns this backup
	RestoreBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Delete a backup identified by the given ID, after which removal of any remote storage of the backup is started.
	// Note that the backup are initially only marked for deletion.
	// Once all remote storage for the backup has been removed, the backup itself is removed.
	// Required permissions:
	// -  backup.backup.delete on the backup identified by the given ID.
	DeleteBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Copy a backup manually from source backup to a given region identifier.
	// It is not allowed to copy backup that does not have upload flag set to true
	// Required permissions:
	// - backup.backup.copy on the backup identified by the given ID.
	CopyBackup(ctx context.Context, in *CopyBackupRequest, opts ...grpc.CallOption) (*Backup, error)
}

type backupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBackupServiceClient(cc grpc.ClientConnInterface) BackupServiceClient {
	return &backupServiceClient{cc}
}

func (c *backupServiceClient) GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error) {
	out := new(v1.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) IsBackupFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error) {
	out := new(v1.YesOrNo)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/IsBackupFeatureAvailable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) IsBackupUploadFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error) {
	out := new(v1.YesOrNo)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/IsBackupUploadFeatureAvailable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) IsMultiRegionBackupUploadFeatureAvailable(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.YesOrNo, error) {
	out := new(v1.YesOrNo)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/IsMultiRegionBackupUploadFeatureAvailable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) ListBackupPolicies(ctx context.Context, in *ListBackupPoliciesRequest, opts ...grpc.CallOption) (*BackupPolicyList, error) {
	out := new(BackupPolicyList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/ListBackupPolicies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) GetBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*BackupPolicy, error) {
	out := new(BackupPolicy)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/GetBackupPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) CreateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error) {
	out := new(BackupPolicy)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/CreateBackupPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) UpdateBackupPolicy(ctx context.Context, in *BackupPolicy, opts ...grpc.CallOption) (*BackupPolicy, error) {
	out := new(BackupPolicy)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/UpdateBackupPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) DeleteBackupPolicy(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/DeleteBackupPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) ListBackups(ctx context.Context, in *ListBackupsRequest, opts ...grpc.CallOption) (*BackupList, error) {
	out := new(BackupList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/ListBackups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) GetBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Backup, error) {
	out := new(Backup)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/GetBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) CreateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error) {
	out := new(Backup)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/CreateBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) UpdateBackup(ctx context.Context, in *Backup, opts ...grpc.CallOption) (*Backup, error) {
	out := new(Backup)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/UpdateBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) DownloadBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/DownloadBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) RestoreBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/RestoreBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) DeleteBackup(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/DeleteBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupServiceClient) CopyBackup(ctx context.Context, in *CopyBackupRequest, opts ...grpc.CallOption) (*Backup, error) {
	out := new(Backup)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.backup.v1.BackupService/CopyBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackupServiceServer is the server API for BackupService service.
type BackupServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error)
	// Checks if the backup feature is enabled and available for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsBackupFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error)
	// Checks if the backup upload feature is enabled for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsBackupUploadFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error)
	// Checks if the multi region backup upload feature is enabled for a specific deployment.
	// Required permissions:
	// - backup.feature.get on the deployment that is identified by the given ID.
	IsMultiRegionBackupUploadFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error)
	// Fetch all backup policies for a specific deployment.
	// Required permissions:
	// - backup.backuppolicy.list on the deployment that owns the backup policies and is identified by the given ID.
	ListBackupPolicies(context.Context, *ListBackupPoliciesRequest) (*BackupPolicyList, error)
	// Fetch a backup policy identified by the given ID.
	// Required permissions:
	// - backup.backuppolicy.get on the backup policy identified by the given ID.
	GetBackupPolicy(context.Context, *v1.IDOptions) (*BackupPolicy, error)
	// Create a new backup policy
	// Required permissions:
	// -  backup.backuppolicy.create on the deployment that owns the backup policy and is identified by the given ID.
	CreateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error)
	// Update a backup policy
	// Required permissions:
	// -  backup.backuppolicy.update on the backup policy identified by the given ID.
	UpdateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error)
	// Delete a backup policy identified by the given ID.
	// Note that the backup policy are initially only marked for deletion, no backups will be deleted with this operation.
	// Once all their dependent backups are removed, the backup policy is removed.
	// Required permissions:
	// -  backup.backuppolicy.delete on the backup policy identified by the given ID.
	DeleteBackupPolicy(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Fetch all backups for a specific deployment.
	// Required permissions:
	// - backup.backup.list on the deployment that owns the backup and is identified by the given ID.
	ListBackups(context.Context, *ListBackupsRequest) (*BackupList, error)
	// Fetch a backup identified by the given ID.
	// Required permissions:
	// - backup.backup.get on the backup identified by the given ID.
	GetBackup(context.Context, *v1.IDOptions) (*Backup, error)
	// Create a new manual backup
	// Setting the backup_policy_id field in the backup is not allowed
	// Required permissions:
	// -  backup.backup.create on the deployment that owns the backup and is identified by the given ID.
	CreateBackup(context.Context, *Backup) (*Backup, error)
	// Update a backup
	// Required permissions:
	// -  backup.backup.update on the backup identified by the given ID.
	UpdateBackup(context.Context, *Backup) (*Backup, error)
	// Download a backup identified by the given ID from remote storage to the volumes of the servers of the deployment.
	// This operation can only be executed on backups which have the same number of DB Servers in the backup and the current running cluster.
	// If this backup was already downloaded, another download will be done.
	// If the backup is still available on the cluster there is no need to explicitly download the backup before restoring.
	// This function will return immediately.
	// To track status, please invoke GetBackup and check the .status field inside the returned backup object
	// Required permissions:
	// -  backup.backup.download on the backup identified by the given ID.
	DownloadBackup(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Restore (or recover) a backup identified by the given ID
	// This operation can only be executed on backups where status.available is set and
	// the mayor and minor version of the backup and the current running cluster are the same.
	// This function will return immediately.
	// To track status, please invoke GetDeployment on the data API and check the
	// .status.restoring_backup and .status.restore_backup_status fields inside the returned deployment object
	// Required permissions (both are needed):
	// -  backup.backup.restore on the backup identified by the given ID.
	// -  data.deployment.restore-backup on the deployment that owns this backup
	RestoreBackup(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Delete a backup identified by the given ID, after which removal of any remote storage of the backup is started.
	// Note that the backup are initially only marked for deletion.
	// Once all remote storage for the backup has been removed, the backup itself is removed.
	// Required permissions:
	// -  backup.backup.delete on the backup identified by the given ID.
	DeleteBackup(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Copy a backup manually from source backup to a given region identifier.
	// It is not allowed to copy backup that does not have upload flag set to true
	// Required permissions:
	// - backup.backup.copy on the backup identified by the given ID.
	CopyBackup(context.Context, *CopyBackupRequest) (*Backup, error)
}

// UnimplementedBackupServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBackupServiceServer struct {
}

func (*UnimplementedBackupServiceServer) GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedBackupServiceServer) IsBackupFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsBackupFeatureAvailable not implemented")
}
func (*UnimplementedBackupServiceServer) IsBackupUploadFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsBackupUploadFeatureAvailable not implemented")
}
func (*UnimplementedBackupServiceServer) IsMultiRegionBackupUploadFeatureAvailable(context.Context, *v1.IDOptions) (*v1.YesOrNo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsMultiRegionBackupUploadFeatureAvailable not implemented")
}
func (*UnimplementedBackupServiceServer) ListBackupPolicies(context.Context, *ListBackupPoliciesRequest) (*BackupPolicyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBackupPolicies not implemented")
}
func (*UnimplementedBackupServiceServer) GetBackupPolicy(context.Context, *v1.IDOptions) (*BackupPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBackupPolicy not implemented")
}
func (*UnimplementedBackupServiceServer) CreateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBackupPolicy not implemented")
}
func (*UnimplementedBackupServiceServer) UpdateBackupPolicy(context.Context, *BackupPolicy) (*BackupPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBackupPolicy not implemented")
}
func (*UnimplementedBackupServiceServer) DeleteBackupPolicy(context.Context, *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBackupPolicy not implemented")
}
func (*UnimplementedBackupServiceServer) ListBackups(context.Context, *ListBackupsRequest) (*BackupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBackups not implemented")
}
func (*UnimplementedBackupServiceServer) GetBackup(context.Context, *v1.IDOptions) (*Backup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBackup not implemented")
}
func (*UnimplementedBackupServiceServer) CreateBackup(context.Context, *Backup) (*Backup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBackup not implemented")
}
func (*UnimplementedBackupServiceServer) UpdateBackup(context.Context, *Backup) (*Backup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBackup not implemented")
}
func (*UnimplementedBackupServiceServer) DownloadBackup(context.Context, *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadBackup not implemented")
}
func (*UnimplementedBackupServiceServer) RestoreBackup(context.Context, *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreBackup not implemented")
}
func (*UnimplementedBackupServiceServer) DeleteBackup(context.Context, *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBackup not implemented")
}
func (*UnimplementedBackupServiceServer) CopyBackup(context.Context, *CopyBackupRequest) (*Backup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyBackup not implemented")
}

func RegisterBackupServiceServer(s *grpc.Server, srv BackupServiceServer) {
	s.RegisterService(&_BackupService_serviceDesc, srv)
}

func _BackupService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).GetAPIVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_IsBackupFeatureAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).IsBackupFeatureAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/IsBackupFeatureAvailable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).IsBackupFeatureAvailable(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_IsBackupUploadFeatureAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).IsBackupUploadFeatureAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/IsBackupUploadFeatureAvailable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).IsBackupUploadFeatureAvailable(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_IsMultiRegionBackupUploadFeatureAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).IsMultiRegionBackupUploadFeatureAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/IsMultiRegionBackupUploadFeatureAvailable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).IsMultiRegionBackupUploadFeatureAvailable(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_ListBackupPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackupPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).ListBackupPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/ListBackupPolicies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).ListBackupPolicies(ctx, req.(*ListBackupPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_GetBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).GetBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/GetBackupPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).GetBackupPolicy(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_CreateBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).CreateBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/CreateBackupPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).CreateBackupPolicy(ctx, req.(*BackupPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_UpdateBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackupPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).UpdateBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/UpdateBackupPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).UpdateBackupPolicy(ctx, req.(*BackupPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_DeleteBackupPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).DeleteBackupPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/DeleteBackupPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).DeleteBackupPolicy(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_ListBackups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).ListBackups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/ListBackups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).ListBackups(ctx, req.(*ListBackupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_GetBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).GetBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/GetBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).GetBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_CreateBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Backup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).CreateBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/CreateBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).CreateBackup(ctx, req.(*Backup))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_UpdateBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Backup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).UpdateBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/UpdateBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).UpdateBackup(ctx, req.(*Backup))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_DownloadBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).DownloadBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/DownloadBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).DownloadBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_RestoreBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).RestoreBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/RestoreBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).RestoreBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_DeleteBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).DeleteBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/DeleteBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).DeleteBackup(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackupService_CopyBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServiceServer).CopyBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.backup.v1.BackupService/CopyBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServiceServer).CopyBackup(ctx, req.(*CopyBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BackupService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.backup.v1.BackupService",
	HandlerType: (*BackupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _BackupService_GetAPIVersion_Handler,
		},
		{
			MethodName: "IsBackupFeatureAvailable",
			Handler:    _BackupService_IsBackupFeatureAvailable_Handler,
		},
		{
			MethodName: "IsBackupUploadFeatureAvailable",
			Handler:    _BackupService_IsBackupUploadFeatureAvailable_Handler,
		},
		{
			MethodName: "IsMultiRegionBackupUploadFeatureAvailable",
			Handler:    _BackupService_IsMultiRegionBackupUploadFeatureAvailable_Handler,
		},
		{
			MethodName: "ListBackupPolicies",
			Handler:    _BackupService_ListBackupPolicies_Handler,
		},
		{
			MethodName: "GetBackupPolicy",
			Handler:    _BackupService_GetBackupPolicy_Handler,
		},
		{
			MethodName: "CreateBackupPolicy",
			Handler:    _BackupService_CreateBackupPolicy_Handler,
		},
		{
			MethodName: "UpdateBackupPolicy",
			Handler:    _BackupService_UpdateBackupPolicy_Handler,
		},
		{
			MethodName: "DeleteBackupPolicy",
			Handler:    _BackupService_DeleteBackupPolicy_Handler,
		},
		{
			MethodName: "ListBackups",
			Handler:    _BackupService_ListBackups_Handler,
		},
		{
			MethodName: "GetBackup",
			Handler:    _BackupService_GetBackup_Handler,
		},
		{
			MethodName: "CreateBackup",
			Handler:    _BackupService_CreateBackup_Handler,
		},
		{
			MethodName: "UpdateBackup",
			Handler:    _BackupService_UpdateBackup_Handler,
		},
		{
			MethodName: "DownloadBackup",
			Handler:    _BackupService_DownloadBackup_Handler,
		},
		{
			MethodName: "RestoreBackup",
			Handler:    _BackupService_RestoreBackup_Handler,
		},
		{
			MethodName: "DeleteBackup",
			Handler:    _BackupService_DeleteBackup_Handler,
		},
		{
			MethodName: "CopyBackup",
			Handler:    _BackupService_CopyBackup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "backup.proto",
}
